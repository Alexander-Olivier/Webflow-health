<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Webflow Project Health Score</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 32px 24px;
      line-height: 1.5;
    }
    .container { max-width: 1000px; margin: 0 auto; }
    header { text-align: center; margin-bottom: 32px; }
    header h1 { font-size: 32px; color: #fff; margin-bottom: 8px; }
    header p { color: #666; font-size: 14px; }

    /* Paste Zone */
    .paste-zone {
      border: 2px dashed #333;
      border-radius: 16px;
      padding: 60px 40px;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
      margin-bottom: 24px;
    }
    .paste-zone:hover, .paste-zone.active { border-color: #4a9eff; background: rgba(74, 158, 255, 0.05); }
    .paste-zone .icon { font-size: 64px; margin-bottom: 16px; }
    .paste-zone h2 { font-size: 20px; color: #888; margin-bottom: 8px; }
    .paste-zone p { font-size: 14px; color: #555; }
    .error-msg { margin-top: 16px; padding: 12px 16px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; color: #ef4444; font-size: 13px; }
    .hidden { display: none !important; }

    /* Collected Pages */
    .collected-section { background: #141414; border: 1px solid #252525; border-radius: 12px; padding: 20px; margin-bottom: 24px; }
    .collected-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    .collected-header h3 { font-size: 16px; color: #fff; }
    .pages-list { display: flex; flex-direction: column; gap: 10px; margin-bottom: 16px; }
    .page-chip { display: flex; justify-content: space-between; align-items: center; padding: 14px 18px; background: #1a1a1a; border-radius: 10px; }
    .page-chip-name { font-weight: 500; color: #e0e0e0; }
    .page-chip-info { display: flex; align-items: center; gap: 16px; }
    .page-chip-stats { display: flex; gap: 12px; font-size: 13px; color: #888; }
    .page-chip-remove { background: none; border: none; color: #555; cursor: pointer; font-size: 20px; padding: 4px 8px; line-height: 1; }
    .page-chip-remove:hover { color: #ef4444; }

    /* Buttons */
    .btn { padding: 12px 20px; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
    .btn-primary { background: #4a9eff; color: #fff; }
    .btn-primary:hover { background: #3a8eef; }
    .btn-success { background: #22c55e; color: #fff; }
    .btn-success:hover { background: #1db954; }
    .btn-secondary { background: #252525; color: #e0e0e0; }
    .btn-secondary:hover { background: #333; }
    .btn-danger { background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.2); }
    .btn-danger:hover { background: rgba(239, 68, 68, 0.2); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-group { display: flex; gap: 12px; flex-wrap: wrap; }
    .btn-sm { padding: 8px 14px; font-size: 13px; }

    /* Modal */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal { background: #1a1a1a; border-radius: 16px; padding: 28px; width: 90%; max-width: 400px; }
    .modal h3 { font-size: 18px; color: #fff; margin-bottom: 8px; }
    .modal p { font-size: 14px; color: #888; margin-bottom: 20px; }
    .modal input { width: 100%; padding: 14px 16px; background: #252525; border: 1px solid #333; border-radius: 8px; color: #e0e0e0; font-size: 15px; margin-bottom: 20px; }
    .modal input:focus { outline: none; border-color: #4a9eff; }
    .modal-actions { display: flex; gap: 12px; }
    .modal-actions .btn { flex: 1; }

    /* Results */
    .results-section { animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .card { background: #141414; border: 1px solid #252525; border-radius: 12px; padding: 24px; margin-bottom: 20px; }
    .card h2 { font-size: 18px; color: #fff; margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }

    /* Score Header */
    .score-header { display: flex; align-items: flex-start; gap: 32px; margin-bottom: 24px; }
    .score-circle { position: relative; width: 160px; height: 160px; flex-shrink: 0; }
    .score-circle svg { transform: rotate(-90deg); width: 100%; height: 100%; }
    .score-circle .bg { fill: none; stroke: #252525; stroke-width: 12; }
    .score-circle .progress { fill: none; stroke: #22c55e; stroke-width: 12; stroke-linecap: round; stroke-dasharray: 408; stroke-dashoffset: 408; transition: stroke-dashoffset 1s ease, stroke 0.3s ease; }
    .score-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
    .score-value { display: block; font-size: 48px; font-weight: 700; color: #22c55e; }
    .score-label { font-size: 11px; color: #666; text-transform: uppercase; letter-spacing: 1px; }
    .score-info { flex: 1; }
    .grade-badge { display: inline-block; padding: 8px 18px; border-radius: 8px; font-size: 18px; font-weight: 600; margin-bottom: 12px; }
    .complexity-badge { display: inline-block; padding: 6px 14px; border-radius: 6px; font-size: 13px; font-weight: 500; margin-left: 12px; }
    .verdict { font-size: 15px; color: #888; line-height: 1.6; margin-bottom: 16px; }
    .framework-badge { display: inline-flex; align-items: center; gap: 8px; padding: 10px 16px; border-radius: 8px; font-size: 14px; font-weight: 500; }
    .framework-badge.detected { background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); color: #22c55e; }
    .framework-badge.none { background: rgba(100, 100, 100, 0.1); border: 1px solid rgba(100, 100, 100, 0.3); color: #888; }
    .intentionality { margin-top: 16px; padding: 14px 18px; background: #1a1a1a; border-radius: 10px; }
    .intentionality-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .intentionality-label { font-size: 13px; color: #888; }
    .intentionality-value { font-size: 15px; font-weight: 600; }
    .intentionality-bar { height: 6px; background: #252525; border-radius: 3px; overflow: hidden; }
    .intentionality-fill { height: 100%; border-radius: 3px; transition: width 0.8s ease; }

    /* Metrics Grid */
    .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 24px; }
    .metric-card { background: #1a1a1a; border-radius: 10px; padding: 18px; }
    .metric-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .metric-title { font-size: 14px; color: #888; }
    .metric-score { font-size: 14px; font-weight: 600; padding: 4px 12px; border-radius: 6px; }
    .metric-score.good { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .metric-score.warning { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .metric-score.bad { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .metric-bar { height: 8px; background: #252525; border-radius: 4px; overflow: hidden; margin-bottom: 10px; }
    .metric-fill { height: 100%; border-radius: 4px; transition: width 0.8s ease; }
    .metric-detail { font-size: 12px; color: #666; }
    .metric-issues { margin-top: 10px; padding-top: 10px; border-top: 1px solid #252525; }
    .metric-issue { font-size: 11px; color: #888; padding: 4px 0; display: flex; align-items: flex-start; gap: 6px; }
    .metric-issue::before { content: "‚Ä¢"; color: #ef4444; }

    /* Brief Section */
    .brief-section { background: #0f1419; border: 1px solid #1e2a3a; border-radius: 12px; padding: 24px; }
    .brief-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    .brief-header h3 { font-size: 16px; color: #fff; }
    .pages-analyzed { font-size: 13px; color: #666; }
    .brief-content { font-size: 14px; color: #c0c0c0; line-height: 1.7; }
    .brief-content p { margin-bottom: 16px; }
    .brief-content strong { color: #fff; }

    /* Priority Issues */
    .priority-section { margin-top: 24px; }
    .priority-section h4 { font-size: 14px; color: #888; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
    .priority-list { display: flex; flex-direction: column; gap: 12px; }
    .priority-item { display: flex; gap: 14px; padding: 14px 16px; background: #141414; border-radius: 10px; border-left: 3px solid; }
    .priority-item.critical { border-color: #ef4444; }
    .priority-item.high { border-color: #f97316; }
    .priority-item.medium { border-color: #fbbf24; }
    .priority-item.low { border-color: #22c55e; }
    .priority-badge { font-size: 10px; font-weight: 600; text-transform: uppercase; padding: 3px 8px; border-radius: 4px; flex-shrink: 0; height: fit-content; }
    .priority-item.critical .priority-badge { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .priority-item.high .priority-badge { background: rgba(249, 115, 22, 0.2); color: #f97316; }
    .priority-item.medium .priority-badge { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .priority-item.low .priority-badge { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .priority-content { flex: 1; }
    .priority-title { font-size: 14px; color: #e0e0e0; margin-bottom: 4px; }
    .priority-desc { font-size: 12px; color: #888; }
    .priority-impact { font-size: 11px; color: #666; margin-top: 6px; font-style: italic; }

    /* Quick Wins */
    .quick-wins { margin-top: 24px; padding: 18px; background: rgba(34, 197, 94, 0.05); border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 10px; }
    .quick-wins h4 { font-size: 14px; color: #22c55e; margin-bottom: 12px; }
    .quick-win-item { display: flex; align-items: flex-start; gap: 10px; padding: 8px 0; font-size: 13px; color: #c0c0c0; }
    .quick-win-item::before { content: "‚úì"; color: #22c55e; font-weight: bold; }

    /* Risk Assessment */
    .risk-section { margin-top: 24px; }
    .risk-section h4 { font-size: 14px; color: #888; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
    .risk-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; }
    .risk-item { padding: 14px; background: #141414; border-radius: 8px; }
    .risk-class { font-family: 'SF Mono', Monaco, monospace; font-size: 13px; color: #4a9eff; margin-bottom: 6px; }
    .risk-reason { font-size: 11px; color: #888; }
    .risk-count { font-size: 11px; color: #f97316; margin-top: 4px; }

    /* Stats Row */
    .stats-row { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; margin-bottom: 24px; }
    .stat-card { background: #1a1a1a; border-radius: 10px; padding: 16px; text-align: center; }
    .stat-value { display: block; font-size: 28px; font-weight: 700; color: #4a9eff; margin-bottom: 4px; }
    .stat-label { font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 0.5px; }

    /* Page Breakdown */
    .breakdown-grid { display: grid; gap: 12px; }
    .breakdown-item { display: flex; justify-content: space-between; align-items: center; padding: 14px 18px; background: #1a1a1a; border-radius: 10px; }
    .breakdown-name { font-weight: 500; font-size: 15px; }
    .breakdown-stats { display: flex; gap: 20px; font-size: 13px; color: #888; }
    .breakdown-stat.warning { color: #fbbf24; }
    .breakdown-stat.bad { color: #ef4444; }

    /* Findings Lists */
    .findings-section { margin-bottom: 24px; }
    .findings-section h3 { font-size: 14px; color: #888; margin-bottom: 14px; }
    .findings-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px; }
    .finding-item { padding: 14px; background: #1a1a1a; border-radius: 8px; border-left: 3px solid #f97316; }
    .finding-title { font-size: 13px; color: #e0e0e0; margin-bottom: 6px; font-weight: 500; }
    .finding-detail { font-size: 12px; color: #888; }
    .finding-classes { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 6px; }
    .finding-class { font-size: 11px; font-family: 'SF Mono', Monaco, monospace; padding: 3px 8px; background: #252525; border-radius: 4px; color: #888; }

    /* Color/Spacing Grids */
    .color-pairs { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; }
    .color-pair { padding: 12px; background: #1a1a1a; border-radius: 8px; }
    .color-pair-swatches { display: flex; gap: 8px; margin-bottom: 8px; }
    .color-pair-swatch { width: 40px; height: 40px; border-radius: 6px; border: 1px solid #333; }
    .color-pair-info { font-size: 11px; color: #888; }
    .color-pair-diff { font-size: 11px; color: #f97316; }

    /* Add More Panel */
    .add-more-panel { background: #141414; border: 1px solid #4a9eff; border-radius: 12px; padding: 20px; margin-bottom: 20px; }
    .add-more-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .add-more-header h3 { font-size: 16px; color: #fff; margin: 0; }
    .add-more-hint { font-size: 13px; color: #888; margin-bottom: 16px; }
    .inline-pages-list { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px; }
    .inline-page-chip { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; background: #1a1a1a; border-radius: 6px; font-size: 13px; }
    .inline-page-chip .count { color: #888; }
    .inline-page-chip.new { border: 1px solid #22c55e; }
    .inline-page-chip .remove-btn { background: none; border: none; color: #555; cursor: pointer; font-size: 14px; padding: 0 2px; }
    .inline-page-chip .remove-btn:hover { color: #ef4444; }
    .add-more-actions { display: flex; gap: 12px; }

    /* Export */
    .export-section { background: #1a1a1a; border-radius: 10px; padding: 20px; }
    .export-actions { display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; }
    .export-output { width: 100%; height: 150px; padding: 14px; background: #0a0a0a; border: 1px solid #333; border-radius: 8px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: #666; resize: vertical; }

    /* Toast */
    .toast { position: fixed; bottom: 32px; left: 50%; transform: translateX(-50%); background: #22c55e; color: #fff; padding: 14px 28px; border-radius: 10px; font-size: 14px; font-weight: 500; z-index: 2000; animation: toastIn 0.3s ease; }
    .toast.error { background: #ef4444; }
    @keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(20px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }

    /* Script Section */
    .script-section { background: #141414; border: 1px solid #252525; border-radius: 12px; padding: 24px; margin-top: 24px; }
    .script-section h3 { font-size: 16px; color: #fff; margin-bottom: 12px; }
    .script-section > p { font-size: 14px; color: #888; margin-bottom: 16px; line-height: 1.6; }
    .script-code { background: #0a0a0a; padding: 18px; border-radius: 10px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; color: #22c55e; overflow-x: auto; position: relative; }
    .script-code .copy-btn { position: absolute; top: 10px; right: 10px; padding: 6px 14px; background: #333; border: none; border-radius: 6px; color: #888; font-size: 12px; cursor: pointer; }
    .script-code .copy-btn:hover { background: #444; color: #e0e0e0; }
    .empty-msg { color: #555; font-style: italic; }

    /* Collapsible sections */
    .collapsible-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 8px 0; }
    .collapsible-header:hover { opacity: 0.8; }
    .collapsible-toggle { color: #666; font-size: 12px; }
    .collapsible-content { overflow: hidden; transition: max-height 0.3s ease; }
    .collapsible-content.collapsed { max-height: 0; }

    /* Tooltips */
    .metric-header { position: relative; }
    .tooltip-trigger { display: inline-flex; align-items: center; gap: 6px; cursor: help; }
    .tooltip-icon { width: 16px; height: 16px; background: #333; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; color: #888; flex-shrink: 0; }
    .tooltip-icon:hover { background: #444; color: #fff; }
    .tooltip-content { position: absolute; left: 0; top: 100%; margin-top: 8px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 14px 16px; font-size: 12px; color: #c0c0c0; line-height: 1.6; width: 280px; z-index: 100; opacity: 0; visibility: hidden; transition: all 0.2s; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .tooltip-content::before { content: ''; position: absolute; top: -6px; left: 20px; width: 10px; height: 10px; background: #1a1a1a; border-left: 1px solid #333; border-top: 1px solid #333; transform: rotate(45deg); }
    .tooltip-trigger:hover + .tooltip-content, .tooltip-content:hover { opacity: 1; visibility: visible; }
    .tooltip-content strong { color: #fff; display: block; margin-bottom: 6px; }
    .tooltip-content ul { margin: 8px 0 0 0; padding-left: 16px; }
    .tooltip-content li { margin: 4px 0; }

    /* Data Explorer */
    .element-types-panel { background: #1a1a1a; border-radius: 10px; padding: 16px; margin-bottom: 16px; }
    .element-types-panel h3 { font-size: 12px; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 12px; }
    .type-tags { display: flex; flex-wrap: wrap; gap: 8px; }
    .type-tag { background: #252525; padding: 6px 12px; border-radius: 6px; font-size: 13px; }
    .type-tag .name { color: #a78bfa; }
    .type-tag .count { color: #666; margin-left: 4px; }

    .explorer-tabs { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; align-items: center; }
    .explorer-tab { padding: 10px 20px; background: #1a1a1a; border: none; border-radius: 8px; color: #888; font-size: 14px; cursor: pointer; transition: all 0.2s; }
    .explorer-tab:hover { background: #252525; color: #e0e0e0; }
    .explorer-tab.active { background: #4a9eff; color: #fff; }
    .explorer-toolbar { display: flex; gap: 8px; margin-left: auto; }

    .explorer-search { width: 100%; padding: 12px 16px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; color: #e0e0e0; font-size: 14px; margin-bottom: 16px; outline: none; }
    .explorer-search:focus { border-color: #4a9eff; }
    .explorer-search::placeholder { color: #555; }

    .explorer-content { background: #1a1a1a; border-radius: 10px; padding: 20px; max-height: 500px; overflow: auto; }
    .explorer-panel.hidden { display: none; }

    /* Tree View */
    .tree-node { padding: 4px 0; }
    .tree-node-header { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 6px; cursor: pointer; font-family: 'SF Mono', Monaco, monospace; font-size: 13px; }
    .tree-node-header:hover { background: #252525; }
    .tree-toggle { width: 16px; color: #555; font-size: 10px; }
    .tree-tag { color: #4a9eff; }
    .tree-type { color: #a78bfa; font-size: 12px; }
    .tree-name { color: #666; font-size: 12px; }
    .tree-classes { color: #00d4aa; font-size: 11px; }
    .tree-children { margin-left: 20px; padding-left: 12px; border-left: 1px solid #252525; }
    .tree-highlight { background: rgba(251, 191, 36, 0.15); }

    /* Styles List */
    .style-item { padding: 14px 0; border-bottom: 1px solid #252525; }
    .style-item:last-child { border-bottom: none; }
    .style-header { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 4px; border-radius: 6px; }
    .style-header:hover { background: #252525; }
    .style-name { color: #00d4aa; font-family: 'SF Mono', Monaco, monospace; font-size: 14px; font-weight: 600; }
    .style-badge { font-size: 10px; padding: 2px 6px; border-radius: 4px; background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .style-variants { font-size: 11px; color: #a78bfa; }
    .style-pages { font-size: 11px; color: #666; margin-left: auto; }
    .style-details { margin-top: 12px; padding-left: 24px; }
    .style-id { font-size: 11px; color: #555; margin-bottom: 8px; }
    .style-css { background: #0a0a0a; padding: 12px; border-radius: 8px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; color: #00d4aa; white-space: pre-wrap; line-height: 1.6; }
    .variant-section { margin-top: 12px; }
    .variant-label { font-size: 11px; color: #a78bfa; margin-bottom: 6px; }
    .variant-name { color: #fbbf24; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; }

    /* Raw JSON */
    .raw-json { font-family: 'SF Mono', Monaco, monospace; font-size: 12px; white-space: pre-wrap; word-break: break-all; color: #888; line-height: 1.5; }

    /* Issue Detail Modal */
    .issue-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.85); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 24px; }
    .issue-modal { background: #1a1a1a; border-radius: 16px; width: 90%; max-width: 700px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; }
    .issue-modal-header { padding: 20px 24px; border-bottom: 1px solid #252525; display: flex; justify-content: space-between; align-items: center; }
    .issue-modal-header h3 { font-size: 18px; color: #fff; margin: 0; }
    .issue-modal-close { background: none; border: none; color: #666; font-size: 24px; cursor: pointer; padding: 4px 8px; line-height: 1; }
    .issue-modal-close:hover { color: #fff; }
    .issue-modal-content { padding: 24px; overflow-y: auto; flex: 1; }
    .issue-modal-desc { font-size: 14px; color: #888; margin-bottom: 20px; line-height: 1.6; }
    .issue-list { display: flex; flex-direction: column; gap: 12px; }
    .issue-list-item { background: #252525; border-radius: 10px; padding: 16px; }
    .issue-list-item-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; flex-wrap: wrap; }
    .issue-list-item-class { font-family: 'SF Mono', Monaco, monospace; font-size: 14px; color: #4a9eff; background: #1a1a1a; padding: 4px 10px; border-radius: 6px; }
    .issue-list-item-badge { font-size: 11px; padding: 3px 8px; border-radius: 4px; }
    .issue-list-item-badge.critical { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    .issue-list-item-badge.high { background: rgba(249, 115, 22, 0.2); color: #f97316; }
    .issue-list-item-badge.medium { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .issue-list-item-badge.low { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .issue-list-item-detail { font-size: 13px; color: #888; }
    .issue-list-item-css { margin-top: 10px; background: #0a0a0a; padding: 12px; border-radius: 8px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; color: #00d4aa; white-space: pre-wrap; max-height: 150px; overflow-y: auto; }
    .issue-list-item-group { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    
    .metric-issue { cursor: pointer; transition: color 0.2s; }
    .metric-issue:hover { color: #4a9eff; }
    .metric-issue::before { content: "‚Ä¢"; color: #ef4444; margin-right: 6px; }

    @media (max-width: 700px) {
      .score-header { flex-direction: column; align-items: center; text-align: center; }
      .stats-row { grid-template-columns: repeat(2, 1fr); }
      .metrics-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üè• Webflow Project Health <span style="font-size: 14px; font-weight: 400; color: #64748b; margin-left: 8px;">v2.9</span></h1>
      <p>Professional analysis for retainer evaluation and maintainability assessment</p>
    </header>

    <div id="pasteZone" class="paste-zone">
      <div class="icon">üìã</div>
      <h2>Paste Webflow JSON here</h2>
      <p>Copy elements from Webflow Designer (Cmd+C), then paste here (Cmd+V)</p>
      <div id="errorMsg" class="error-msg hidden"></div>
    </div>

    <div id="collectedSection" class="collected-section hidden">
      <div class="collected-header">
        <h3>üìÑ Collected Pages (<span id="pageCount">0</span>)</h3>
        <button class="btn btn-danger btn-sm" id="clearAllBtn">üóëÔ∏è Clear All</button>
      </div>
      <div id="pagesList" class="pages-list"></div>
      <div class="btn-group">
        <button class="btn btn-success" id="analyzeBtn">üîç Analyze Project</button>
        <span style="color: #666; font-size: 13px; display: flex; align-items: center;">Paste more pages to add them</span>
      </div>
    </div>

    <div id="resultsSection" class="results-section hidden">
      <!-- Add More Panel -->
      <div id="addMorePanel" class="add-more-panel hidden">
        <div class="add-more-header">
          <h3>‚ûï Add More Pages</h3>
          <button class="btn btn-secondary btn-sm" id="closeAddMoreBtn">‚úï Close</button>
        </div>
        <p class="add-more-hint">Paste more Webflow data to add pages, then click Refresh</p>
        <div id="inlinePagesList" class="inline-pages-list"></div>
        <div class="add-more-actions">
          <button class="btn btn-success" id="refreshAnalysisBtn">üîÑ Refresh Analysis</button>
        </div>
      </div>

      <!-- Score Overview -->
      <div class="card">
        <h2>üìä Analysis Results</h2>
        <div class="score-header">
          <div class="score-circle">
            <svg viewBox="0 0 160 160">
              <circle class="bg" cx="80" cy="80" r="65"></circle>
              <circle class="progress" id="scoreProgress" cx="80" cy="80" r="65"></circle>
            </svg>
            <div class="score-text">
              <span class="score-value" id="scoreValue">0</span>
              <span class="score-label">Health</span>
            </div>
          </div>
          <div class="score-info">
            <div>
              <span class="grade-badge" id="gradeBadge">Grade: ?</span>
              <span class="complexity-badge" id="complexityBadge">Loading...</span>
            </div>
            <p class="verdict" id="verdictText">Analyzing...</p>
            <div class="framework-badge none" id="frameworkBadge">Checking framework...</div>
            <div class="intentionality">
              <div class="intentionality-header">
                <span class="intentionality-label">Intentionality Score</span>
                <span class="intentionality-value" id="intentionalityValue">0%</span>
              </div>
              <div class="intentionality-bar">
                <div class="intentionality-fill" id="intentionalityFill"></div>
              </div>
            </div>
          </div>
        </div>
        <div class="metrics-grid" id="metricsGrid"></div>
        <div class="stats-row" id="statsRow"></div>
      </div>

      <!-- Brief -->
      <div class="card brief-section" id="briefCard">
        <div class="brief-header">
          <h3>üìã Analysis Brief</h3>
          <span class="pages-analyzed" id="pagesAnalyzed">1 page analyzed</span>
        </div>
        <div class="brief-content" id="briefContent"></div>
        
        <div class="priority-section">
          <h4>üéØ Priority Recommendations</h4>
          <div class="priority-list" id="priorityList"></div>
        </div>

        <div class="quick-wins" id="quickWins">
          <h4>‚ö° Quick Wins</h4>
          <div id="quickWinsList"></div>
        </div>

        <div class="risk-section" id="riskSection">
          <h4>‚ö†Ô∏è High-Risk Classes (Modify with Caution)</h4>
          <div class="risk-grid" id="riskGrid"></div>
        </div>
      </div>

      <!-- Per-Page Breakdown -->
      <div class="card" id="breakdownCard" style="display:none;">
        <h2>üìÑ Per-Page Breakdown</h2>
        <div class="breakdown-grid" id="pageBreakdown"></div>
      </div>

      <!-- Detailed Findings -->
      <div class="card" id="findingsCard">
        <h2>üîç Detailed Findings</h2>
        
        <div class="findings-section" id="duplicateStylesSection">
          <h3>üîÑ Duplicate Styles (Different Names, Same CSS)</h3>
          <div class="findings-grid" id="duplicateStylesList"></div>
        </div>

        <div class="findings-section" id="nearDuplicateColorsSection">
          <h3>üé® Near-Duplicate Colors</h3>
          <div class="color-pairs" id="nearDuplicateColorsList"></div>
        </div>

        <div class="findings-section" id="inconsistentSpacingSection">
          <h3>üìê Inconsistent Spacing</h3>
          <div class="findings-grid" id="inconsistentSpacingList"></div>
        </div>

        <div class="findings-section" id="autoGeneratedSection">
          <h3>ü§ñ Auto-Generated Classes</h3>
          <div class="findings-grid" id="autoGeneratedList"></div>
        </div>

        <div class="findings-section" id="nestingSection">
          <h3>üì¶ Deep Nesting Issues</h3>
          <div class="findings-grid" id="nestingList"></div>
        </div>

        <div class="findings-section" id="positioningSection">
          <h3>üéØ Positioning Concerns</h3>
          <div class="findings-grid" id="positioningList"></div>
        </div>

        <div class="findings-section" id="breakpointSection">
          <h3>üì± Breakpoint Issues</h3>
          <div class="findings-grid" id="breakpointList"></div>
        </div>

        <div class="findings-section" id="globalComboSection">
          <h3>üîó Global Class Combo Overload</h3>
          <div class="findings-grid" id="globalComboList"></div>
        </div>
      </div>

      <!-- Data Explorer -->
      <div class="card" id="explorerCard">
        <h2>üîé Data Explorer</h2>
        
        <!-- Element Types -->
        <div class="element-types-panel">
          <h3>Element Types</h3>
          <div class="type-tags" id="explorerTypeTags"></div>
        </div>

        <!-- Tabs & Toolbar -->
        <div class="explorer-tabs">
          <button class="explorer-tab active" data-tab="tree">Element Tree</button>
          <button class="explorer-tab" data-tab="styles">Styles <span id="explorerStylesCount"></span></button>
          <button class="explorer-tab" data-tab="raw">Raw JSON</button>
          <div class="explorer-toolbar">
            <button class="btn btn-sm" id="explorerExpandBtn">Expand All</button>
            <button class="btn btn-sm" id="explorerCollapseBtn">Collapse All</button>
          </div>
        </div>

        <!-- Search -->
        <input type="text" class="explorer-search" id="explorerSearch" placeholder="Search elements or classes...">

        <!-- Content Panels -->
        <div class="explorer-content">
          <div id="explorerTreeContent" class="explorer-panel"></div>
          <div id="explorerStylesContent" class="explorer-panel hidden"></div>
          <div id="explorerRawContent" class="explorer-panel hidden"></div>
        </div>
      </div>

      <!-- Export -->
      <div class="card">
        <h2>üì§ Export</h2>
        <div class="export-section">
          <div class="export-actions">
            <button class="btn btn-primary" id="copyJsonBtn">üìã Copy JSON</button>
            <button class="btn btn-secondary" id="downloadJsonBtn">üíæ Download Report</button>
            <button class="btn btn-secondary" id="addMoreBtn">‚ûï Add More Pages</button>
            <button class="btn btn-secondary" id="startOverBtn">üîÑ Start Over</button>
          </div>
          <textarea class="export-output" id="exportOutput" readonly></textarea>
        </div>
      </div>
    </div>

    <!-- Page Name Modal -->
    <div id="pageNameModal" class="modal-overlay hidden">
      <div class="modal">
        <h3>Name this page</h3>
        <p>Enter a name for this page (e.g., Homepage, About, Contact)</p>
        <input type="text" id="pageNameInput" placeholder="Page name...">
        <div class="modal-actions">
          <button class="btn btn-secondary" id="cancelPageBtn">Cancel</button>
          <button class="btn btn-primary" id="savePageBtn">Add Page</button>
        </div>
      </div>
    </div>

    <!-- Issue Detail Modal -->
    <div id="issueModal" class="issue-modal-overlay hidden">
      <div class="issue-modal">
        <div class="issue-modal-header">
          <h3 id="issueModalTitle">Issue Details</h3>
          <button class="issue-modal-close" id="issueModalClose">&times;</button>
        </div>
        <div class="issue-modal-content">
          <p class="issue-modal-desc" id="issueModalDesc"></p>
          <div class="issue-list" id="issueModalList"></div>
        </div>
      </div>
    </div>

    <!-- Script Section -->
    <div class="script-section">
      <h3>üìù How to copy from Webflow</h3>
      <p>Run this script in the browser console while in Webflow Designer, then copy any element:</p>
      <div class="script-code">
        <button class="copy-btn" id="copyScriptBtn">Copy</button>
        <code>document.addEventListener('copy', ({ clipboardData }) => {
  const webflowData = clipboardData.getData('application/json');
  const type = 'text/plain';
  const blob = new Blob([webflowData], { type });
  const data = [new ClipboardItem({ [type]: blob })];
  navigator.clipboard.write(data);
  console.log('Copied! Paste into the viewer.');
});</code>
      </div>
    </div>
  </div>

<script>
// ============================================================================
// WEBFLOW PROJECT HEALTH ANALYZER v2.0
// Professional analysis for retainer evaluation and maintainability assessment
// ============================================================================

// ========== CONFIGURATION ==========

const FRAMEWORKS = {
  'Client-First': {
    required: ['page_', 'padding-global'],
    patterns: ['page_', 'section_', 'padding-global', 'padding-section-', 'container-', 'margin-', 'text-size-', 'heading-style-', 'button_', 'spacer-', 'is-', 'text-color-', 'background-color-'],
    minMatches: 6,
    expectsMoreClasses: true,
    expectsExplanatoryNames: true
  },
  'MAST': {
    required: ['page-wrapper'],
    patterns: ['page-wrapper', 'page-main', 'section', 'container', 'row', 'col-', 'slot', 'u-', 'cc-', 'is-', 'c-', 'l-'],
    minMatches: 5,
    expectsUtilityClasses: true
  },
  'Lumos': {
    required: [],
    patterns: ['l-section', 'l-container', 'l-grid', 'l-', 'lumos-', 'l-row', 'l-col'],
    minMatches: 4
  },
  'Relume': {
    required: [],
    patterns: ['navbar_component', 'footer_component', 'section_', 'padding-vertical', 'layout_', 'rl_', 'button-group'],
    minMatches: 4
  }
};

const AUTO_GENERATED_PATTERNS = [
  { pattern: /^div-block$/i, severity: 'medium', desc: 'Unnamed div' },
  { pattern: /^div-block-\d+$/i, severity: 'high', desc: 'Numbered div' },
  { pattern: /^section$/i, severity: 'low', desc: 'Generic section' },
  { pattern: /^section-\d+$/i, severity: 'high', desc: 'Numbered section' },
  { pattern: /^container$/i, severity: 'low', desc: 'Generic container' },
  { pattern: /^container-\d+$/i, severity: 'high', desc: 'Numbered container' },
  { pattern: /^heading$/i, severity: 'low', desc: 'Generic heading' },
  { pattern: /^heading-\d+$/i, severity: 'high', desc: 'Numbered heading' },
  { pattern: /^paragraph$/i, severity: 'low', desc: 'Generic paragraph' },
  { pattern: /^paragraph-\d+$/i, severity: 'high', desc: 'Numbered paragraph' },
  { pattern: /^text-block$/i, severity: 'medium', desc: 'Unnamed text block' },
  { pattern: /^text-block-\d+$/i, severity: 'high', desc: 'Numbered text block' },
  { pattern: /^link-block$/i, severity: 'medium', desc: 'Unnamed link block' },
  { pattern: /^link-block-\d+$/i, severity: 'high', desc: 'Numbered link block' },
  { pattern: /^image$/i, severity: 'low', desc: 'Generic image' },
  { pattern: /^image-\d+$/i, severity: 'high', desc: 'Numbered image' },
  { pattern: /^button$/i, severity: 'low', desc: 'Generic button' },
  { pattern: /^button-\d+$/i, severity: 'high', desc: 'Numbered button' },
  { pattern: /^grid$/i, severity: 'low', desc: 'Generic grid' },
  { pattern: /^grid-\d+$/i, severity: 'high', desc: 'Numbered grid' },
  { pattern: /^columns$/i, severity: 'low', desc: 'Generic columns' },
  { pattern: /^columns-\d+$/i, severity: 'high', desc: 'Numbered columns' },
  { pattern: /^column$/i, severity: 'low', desc: 'Generic column' },
  { pattern: /^column-\d+$/i, severity: 'high', desc: 'Numbered column' },
  { pattern: /^wrapper$/i, severity: 'low', desc: 'Generic wrapper' },
  { pattern: /^wrapper-\d+$/i, severity: 'high', desc: 'Numbered wrapper' },
  { pattern: /^block$/i, severity: 'medium', desc: 'Unnamed block' },
  { pattern: /^block-\d+$/i, severity: 'high', desc: 'Numbered block' },
  { pattern: /^.+-copy$/i, severity: 'critical', desc: 'Copied class' },
  { pattern: /^.+-copy-\d+$/i, severity: 'critical', desc: 'Multiple copies' },
  { pattern: /^copy-of-.+$/i, severity: 'critical', desc: 'Copy of class' },
  { pattern: /^slider$/i, severity: 'low', desc: 'Generic slider' },
  { pattern: /^slider-\d+$/i, severity: 'high', desc: 'Numbered slider' },
  { pattern: /^slide$/i, severity: 'low', desc: 'Generic slide' },
  { pattern: /^slide-\d+$/i, severity: 'high', desc: 'Numbered slide' },
  { pattern: /^tabs$/i, severity: 'low', desc: 'Generic tabs' },
  { pattern: /^tabs-\d+$/i, severity: 'high', desc: 'Numbered tabs' },
  { pattern: /^tab-link$/i, severity: 'low', desc: 'Generic tab link' },
  { pattern: /^tab-link-\d+$/i, severity: 'high', desc: 'Numbered tab link' },
  { pattern: /^navbar$/i, severity: 'low', desc: 'Generic navbar' },
  { pattern: /^navbar-\d+$/i, severity: 'high', desc: 'Numbered navbar' },
  { pattern: /^dropdown$/i, severity: 'low', desc: 'Generic dropdown' },
  { pattern: /^dropdown-\d+$/i, severity: 'high', desc: 'Numbered dropdown' },
  { pattern: /^form-block$/i, severity: 'low', desc: 'Generic form' },
  { pattern: /^form-block-\d+$/i, severity: 'high', desc: 'Numbered form' },
  { pattern: /^text-field$/i, severity: 'low', desc: 'Generic text field' },
  { pattern: /^text-field-\d+$/i, severity: 'high', desc: 'Numbered text field' },
  { pattern: /^rich-text$/i, severity: 'low', desc: 'Generic rich text' },
  { pattern: /^rich-text-\d+$/i, severity: 'high', desc: 'Numbered rich text' },
  { pattern: /^html-embed$/i, severity: 'low', desc: 'Generic embed' },
  { pattern: /^html-embed-\d+$/i, severity: 'high', desc: 'Numbered embed' },
];

const SPACING_SCALES = {
  '4px': [0, 2, 4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256],
  '8px': [0, 4, 8, 16, 24, 32, 40, 48, 64, 80, 96, 112, 128, 160, 192, 224, 256],
  '5px': [0, 5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 70, 80, 100, 120, 140, 160, 200]
};

// Webflow breakpoint name mapping
const BREAKPOINT_NAMES = {
  'xxl': '1920px+',
  'xl': '1440px',
  'large': '1280px',
  'medium': 'Tablet (991px)',
  'small': 'Mobile Landscape (767px)',
  'tiny': 'Mobile Portrait (478px)',
  'main': 'Desktop (base)',
  'base': 'Desktop (base)'
};

// ========== STATE ==========

let collectedPages = [];
let pendingData = null;
let analysisResult = null;
let lastAnalyzedCount = 0;

// ========== DOM ELEMENTS ==========

const els = {};
const elementIds = [
  'pasteZone', 'errorMsg', 'collectedSection', 'pageCount', 'pagesList', 'analyzeBtn', 'clearAllBtn',
  'resultsSection', 'scoreProgress', 'scoreValue', 'gradeBadge', 'complexityBadge', 'verdictText',
  'frameworkBadge', 'intentionalityValue', 'intentionalityFill', 'metricsGrid', 'statsRow',
  'briefCard', 'pagesAnalyzed', 'briefContent', 'priorityList', 'quickWinsList', 'riskGrid',
  'breakdownCard', 'pageBreakdown', 'findingsCard', 'duplicateStylesList', 'nearDuplicateColorsList',
  'inconsistentSpacingList', 'autoGeneratedList', 'nestingList', 'positioningList',
  'breakpointList', 'globalComboList',
  'exportOutput', 'copyJsonBtn', 'downloadJsonBtn', 'addMoreBtn', 'startOverBtn',
  'addMorePanel', 'closeAddMoreBtn', 'refreshAnalysisBtn', 'inlinePagesList',
  'pageNameModal', 'pageNameInput', 'cancelPageBtn', 'savePageBtn', 'copyScriptBtn',
  'duplicateStylesSection', 'nearDuplicateColorsSection', 'inconsistentSpacingSection',
  'autoGeneratedSection', 'nestingSection', 'positioningSection', 'breakpointSection', 
  'globalComboSection', 'quickWins', 'riskSection',
  'explorerCard', 'explorerTypeTags', 'explorerStylesCount', 'explorerSearch',
  'explorerTreeContent', 'explorerStylesContent', 'explorerRawContent',
  'explorerExpandBtn', 'explorerCollapseBtn'
];
elementIds.forEach(id => els[id] = document.getElementById(id));

// Issue modal elements
els.issueModal = document.getElementById('issueModal');
els.issueModalTitle = document.getElementById('issueModalTitle');
els.issueModalDesc = document.getElementById('issueModalDesc');
els.issueModalList = document.getElementById('issueModalList');
els.issueModalClose = document.getElementById('issueModalClose');

// Explorer state
let explorerExpandedNodes = new Set();
let explorerActiveTab = 'tree';
let explorerSearchTerm = '';

// Issue detail data mapping
const issueDataMap = new Map();

// ========== EVENT LISTENERS ==========

document.addEventListener('paste', handlePaste);
els.analyzeBtn?.addEventListener('click', analyzeAll);
els.clearAllBtn?.addEventListener('click', clearAll);
els.copyJsonBtn?.addEventListener('click', copyJson);
els.downloadJsonBtn?.addEventListener('click', downloadJson);
els.addMoreBtn?.addEventListener('click', showAddMorePanel);
els.closeAddMoreBtn?.addEventListener('click', hideAddMorePanel);
els.refreshAnalysisBtn?.addEventListener('click', () => { hideAddMorePanel(); analyzeAll(); });
els.startOverBtn?.addEventListener('click', startOver);
els.cancelPageBtn?.addEventListener('click', hideModal);
els.savePageBtn?.addEventListener('click', savePage);
els.pageNameInput?.addEventListener('keypress', e => { if (e.key === 'Enter') savePage(); });
els.copyScriptBtn?.addEventListener('click', () => {
  navigator.clipboard.writeText(document.querySelector('.script-code code').textContent);
  els.copyScriptBtn.textContent = 'Copied!';
  setTimeout(() => els.copyScriptBtn.textContent = 'Copy', 2000);
});

// Explorer event listeners
document.querySelectorAll('.explorer-tab').forEach(tab => {
  tab.addEventListener('click', () => switchExplorerTab(tab.dataset.tab));
});
els.explorerExpandBtn?.addEventListener('click', expandAllExplorer);
els.explorerCollapseBtn?.addEventListener('click', collapseAllExplorer);
els.explorerSearch?.addEventListener('input', (e) => {
  explorerSearchTerm = e.target.value.toLowerCase();
  renderExplorer();
});

// Issue modal events
els.issueModalClose?.addEventListener('click', hideIssueModal);
els.issueModal?.addEventListener('click', (e) => {
  if (e.target === els.issueModal) hideIssueModal();
});

// ========== UTILITY FUNCTIONS ==========

function showToast(msg, isError = false) {
  const t = document.createElement('div');
  t.className = `toast ${isError ? 'error' : ''}`;
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 2500);
}

function showError(msg) {
  if (msg) { els.errorMsg.textContent = msg; els.errorMsg.classList.remove('hidden'); }
  else els.errorMsg.classList.add('hidden');
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// ========== ISSUE MODAL ==========

function showIssueModal(issueType) {
  const data = issueDataMap.get(issueType);
  if (!data) return;
  
  els.issueModalTitle.textContent = data.title;
  els.issueModalDesc.textContent = data.description;
  els.issueModalList.innerHTML = data.render();
  els.issueModal.classList.remove('hidden');
}

function hideIssueModal() {
  els.issueModal.classList.add('hidden');
}

// Make showIssueModal globally accessible for onclick handlers
window.showIssueModal = showIssueModal;

function registerIssueData(type, title, description, renderFn) {
  issueDataMap.set(type, { title, description, render: renderFn });
}

// ========== PAGE MANAGEMENT ==========

function updateUI() {
  const has = collectedPages.length > 0;
  els.collectedSection.classList.toggle('hidden', !has);
  els.pageCount.textContent = collectedPages.length;
  els.pagesList.innerHTML = collectedPages.map((p, i) => `
    <div class="page-chip">
      <span class="page-chip-name">${escapeHtml(p.name)}</span>
      <div class="page-chip-info">
        <div class="page-chip-stats">
          <span>${p.classCount} classes</span>
          <span>${p.elementCount} elements</span>
        </div>
        <button class="page-chip-remove" onclick="removePage(${i})">&times;</button>
      </div>
    </div>
  `).join('');
}

window.removePage = i => { collectedPages.splice(i, 1); updateUI(); updateInlinePagesList(); };

function clearAll() { 
  collectedPages = []; 
  lastAnalyzedCount = 0; 
  updateUI(); 
  showToast('Cleared all pages'); 
}

function startOver() { 
  collectedPages = []; 
  analysisResult = null; 
  lastAnalyzedCount = 0; 
  els.resultsSection.classList.add('hidden'); 
  els.pasteZone.classList.remove('hidden'); 
  els.addMorePanel.classList.add('hidden'); 
  updateUI(); 
}

function showAddMorePanel() {
  els.addMorePanel.classList.remove('hidden');
  updateInlinePagesList();
}

function hideAddMorePanel() {
  els.addMorePanel.classList.add('hidden');
}

function updateInlinePagesList() {
  els.inlinePagesList.innerHTML = collectedPages.map((p, i) => {
    const isNew = i >= lastAnalyzedCount;
    return `<div class="inline-page-chip ${isNew ? 'new' : ''}">
      <span>${escapeHtml(p.name)}</span>
      <span class="count">${p.classCount}</span>
      <button class="remove-btn" onclick="removePageInline(${i})">&times;</button>
    </div>`;
  }).join('');
  els.refreshAnalysisBtn.disabled = collectedPages.length === lastAnalyzedCount;
  els.refreshAnalysisBtn.textContent = collectedPages.length > lastAnalyzedCount 
    ? `üîÑ Refresh Analysis (+${collectedPages.length - lastAnalyzedCount} new)`
    : 'üîÑ Refresh Analysis';
}

window.removePageInline = i => { collectedPages.splice(i, 1); updateInlinePagesList(); };

function showModal() {
  els.pageNameInput.value = `Page ${collectedPages.length + 1}`;
  els.pageNameModal.classList.remove('hidden');
  els.pageNameInput.focus();
  els.pageNameInput.select();
}

function hideModal() {
  els.pageNameModal.classList.add('hidden');
  pendingData = null;
}

function handlePaste(e) {
  const text = e.clipboardData.getData('text/plain') || e.clipboardData.getData('application/json');
  if (!text) return;
  try {
    const parsed = JSON.parse(text);
    if (parsed.type === '@webflow/XscpData') {
      showError('');
      pendingData = parsed;
      showModal();
    } else {
      showError('Valid JSON but not Webflow format. Expected type: @webflow/XscpData');
    }
  } catch (err) {
    showError('Invalid JSON: ' + err.message);
  }
}

function savePage() {
  if (!pendingData) return;
  const name = els.pageNameInput.value.trim() || `Page ${collectedPages.length + 1}`;
  const { payload, meta } = pendingData;
  const styles = payload?.styles || [];
  const nodes = payload?.nodes || [];
  const interactions = payload?.ix2?.interactions || [];

  collectedPages.push({
    name,
    classCount: styles.length,
    elementCount: nodes.length,
    interactionCount: interactions.length,
    styles,
    nodes,
    interactions,
    meta: meta || {},
    rawData: pendingData
  });

  hideModal();
  updateUI();
  if (!els.addMorePanel.classList.contains('hidden')) updateInlinePagesList();
  showToast(`Added "${name}" with ${styles.length} classes`);
}

// ========== ANALYSIS ENGINE ==========

function analyzeAll() {
  if (!collectedPages.length) return;
  
  // Aggregate all data
  const aggregated = aggregateData();
  
  // Run all analyses
  const framework = detectFramework(aggregated.allClassNames);
  const frameworkConfig = framework ? FRAMEWORKS[framework] : null;
  
  const naming = analyzeNaming(aggregated, frameworkConfig);
  const styleConsistency = analyzeStyleConsistency(aggregated, frameworkConfig);
  const typography = analyzeTypography(aggregated);
  const architecture = analyzeArchitecture(aggregated, frameworkConfig);
  const components = analyzeComponents(aggregated, frameworkConfig);
  const maintainability = analyzeMaintainability(aggregated, frameworkConfig);
  const technical = analyzeTechnical(aggregated);
  
  // Calculate scores
  const metrics = { naming, styleConsistency, typography, architecture, components, maintainability, technical };
  let totalScore = 0;
  Object.values(metrics).forEach(m => totalScore += m.score);
  
  // Calculate intentionality
  const intentionality = calculateIntentionality(aggregated, metrics);
  
  // Determine complexity rating
  const complexity = determineComplexity(totalScore, aggregated, metrics);
  
  // Generate findings
  const findings = generateFindings(aggregated, metrics);
  
  // Generate recommendations
  const recommendations = generateRecommendations(metrics, findings, framework);
  
  // Generate quick wins
  const quickWins = generateQuickWins(metrics, findings);
  
  // Generate risk assessment
  const riskAssessment = generateRiskAssessment(aggregated);
  
  // Generate brief
  const brief = generateBrief(aggregated, metrics, framework, complexity, findings);
  
  analysisResult = {
    score: totalScore,
    grade: getGrade(totalScore),
    complexity,
    intentionality,
    framework,
    frameworkConfig,
    metrics,
    findings,
    recommendations,
    quickWins,
    riskAssessment,
    brief,
    aggregated,
    pages: collectedPages.map(p => ({ name: p.name, classCount: p.classCount, elementCount: p.elementCount }))
  };
  
  lastAnalyzedCount = collectedPages.length;
  displayResults();
}

function aggregateData() {
  const styleMap = new Map();
  const allNodes = [];
  const allInteractions = [];
  let totalElements = 0;
  let unlinkedSymbols = 0;
  
  collectedPages.forEach((page, pageIndex) => {
    totalElements += page.elementCount;
    unlinkedSymbols += page.meta?.unlinkedSymbolCount || 0;
    
    page.styles.forEach(style => {
      if (!styleMap.has(style._id)) {
        styleMap.set(style._id, {
          ...style,
          usedOnPages: [page.name],
          pageIndices: [pageIndex]
        });
      } else {
        const existing = styleMap.get(style._id);
        // Only add page if not already tracked
        if (!existing.usedOnPages.includes(page.name)) {
          existing.usedOnPages.push(page.name);
          existing.pageIndices.push(pageIndex);
        }
      }
    });
    
    page.nodes.forEach(node => {
      allNodes.push({ ...node, pageName: page.name, pageIndex });
    });
    
    (page.interactions || []).forEach(ix => {
      allInteractions.push({ ...ix, pageName: page.name });
    });
  });
  
  const allStyles = Array.from(styleMap.values());
  const allClassNames = allStyles.map(s => s.name).filter(Boolean);
  const allCss = allStyles.map(s => s.styleLess || '').join('; ');
  
  // Build node tree for nesting analysis
  const nodeMap = {};
  allNodes.forEach(n => nodeMap[n._id] = n);
  
  return {
    allStyles,
    allClassNames,
    allCss,
    allNodes,
    nodeMap,
    allInteractions,
    totalElements,
    unlinkedSymbols,
    pageCount: collectedPages.length,
    pages: collectedPages
  };
}

// ========== FRAMEWORK DETECTION ==========

function detectFramework(classNames) {
  const lower = classNames.map(n => n.toLowerCase());
  let bestMatch = null;
  let bestScore = 0;
  
  for (const [name, config] of Object.entries(FRAMEWORKS)) {
    const hasRequired = config.required.length === 0 || 
      config.required.every(req => lower.some(cn => cn.includes(req.toLowerCase())));
    
    if (!hasRequired) continue;
    
    let matches = 0;
    config.patterns.forEach(p => {
      if (lower.some(cn => cn.includes(p.toLowerCase()))) matches++;
    });
    
    if (matches >= config.minMatches && matches > bestScore) {
      bestMatch = name;
      bestScore = matches;
    }
  }
  
  return bestMatch;
}

// ========== NAMING ANALYSIS (20 pts) ==========

function analyzeNaming(aggregated, frameworkConfig) {
  const { allStyles, allClassNames } = aggregated;
  const issues = [];
  let score = 20;
  
  // 1. Auto-generated classes analysis
  const autoGenerated = { low: [], medium: [], high: [], critical: [] };
  
  allClassNames.forEach(name => {
    for (const { pattern, severity, desc } of AUTO_GENERATED_PATTERNS) {
      if (pattern.test(name)) {
        autoGenerated[severity].push({ name, desc });
        break;
      }
    }
  });
  
  const totalAuto = autoGenerated.low.length + autoGenerated.medium.length + 
                    autoGenerated.high.length + autoGenerated.critical.length;
  const autoRatio = totalAuto / (allClassNames.length || 1);
  
  // Deduct based on severity
  if (autoGenerated.critical.length > 0) {
    score -= Math.min(8, autoGenerated.critical.length * 2);
    issues.push(`${autoGenerated.critical.length} copied classes (critical)`);
  }
  if (autoGenerated.high.length > 3) {
    score -= Math.min(6, Math.floor(autoGenerated.high.length / 2));
    issues.push(`${autoGenerated.high.length} numbered auto-classes`);
  }
  if (autoRatio > 0.3) {
    score -= 4;
    issues.push(`${Math.round(autoRatio * 100)}% auto-generated overall`);
  } else if (autoRatio > 0.15) {
    score -= 2;
  }
  
  // 2. Check for duplicate CSS with different names
  const cssToClasses = new Map();
  allStyles.forEach(style => {
    if (style.styleLess && style.styleLess.length > 10) {
      const normalized = normalizeCss(style.styleLess);
      if (!cssToClasses.has(normalized)) {
        cssToClasses.set(normalized, []);
      }
      cssToClasses.get(normalized).push(style.name);
    }
  });
  
  const duplicateCss = Array.from(cssToClasses.entries())
    .filter(([css, names]) => names.length > 1)
    .map(([css, names]) => ({ css: css.substring(0, 100), names }));
  
  if (duplicateCss.length > 5) {
    score -= 3;
    issues.push(`${duplicateCss.length} groups of duplicate styles`);
  } else if (duplicateCss.length > 2) {
    score -= 1;
  }
  
  // 3. Naming convention consistency
  const conventions = detectNamingConventions(allClassNames);
  if (conventions.mixed > 3) {
    score -= 2;
    issues.push('Mixed naming conventions detected');
  }
  
  // 4. Check auto-generated with identical CSS (worst case)
  const numberedWithSameCss = findNumberedWithSameCss(allStyles);
  if (numberedWithSameCss.length > 0) {
    score -= Math.min(4, numberedWithSameCss.length);
    issues.push(`${numberedWithSameCss.length} numbered classes with identical CSS`);
  }
  
  return {
    score: Math.max(0, score),
    max: 20,
    detail: `${totalAuto} auto-generated, ${duplicateCss.length} duplicate styles`,
    issues,
    data: { autoGenerated, duplicateCss, conventions, numberedWithSameCss }
  };
}

function normalizeCss(css) {
  return css.toLowerCase().replace(/\s+/g, ' ').trim();
}

function detectNamingConventions(classNames) {
  const conventions = {
    kebab: 0,      // my-class-name
    camel: 0,      // myClassName
    snake: 0,      // my_class_name
    bemmish: 0,    // block__element--modifier
    prefixed: {},  // is-, cc-, u-, etc.
    mixed: 0
  };
  
  const prefixPattern = /^(is-|cc-|u-|c-|l-|js-|w-|has-)/i;
  
  classNames.forEach(name => {
    if (prefixPattern.test(name)) {
      const prefix = name.match(prefixPattern)[1].toLowerCase();
      conventions.prefixed[prefix] = (conventions.prefixed[prefix] || 0) + 1;
    }
    if (name.includes('__') || name.includes('--')) conventions.bemmish++;
    else if (name.includes('_')) conventions.snake++;
    else if (/[a-z][A-Z]/.test(name)) conventions.camel++;
    else if (name.includes('-')) conventions.kebab++;
  });
  
  // Check for mixed conventions
  const prefixTypes = Object.keys(conventions.prefixed);
  if (prefixTypes.length > 2) {
    conventions.mixed = prefixTypes.length;
  }
  
  return conventions;
}

function findNumberedWithSameCss(styles) {
  // Group styles by their BASE name (without trailing numbers or -copy suffix)
  const baseGroups = new Map();
  
  styles.forEach(style => {
    if (!style.styleLess || style.styleLess.length < 5) return;
    
    const name = style.name || '';
    
    // Skip Webflow auto-generated component variant classes (Style 1, Style 2, etc.)
    if (/^Style\s*\d+$/i.test(name)) return;
    
    // Extract base name: heading-1 -> heading, card-copy -> card, section-2-copy -> section-2
    const baseName = name
      .replace(/-copy(-\d+)?$/i, '')  // Remove -copy and -copy-2
      .replace(/-?\d+$/, '');          // Remove trailing numbers
    
    if (!baseName || baseName === name) return; // Skip if no number/copy suffix
    
    const key = baseName.toLowerCase();
    if (!baseGroups.has(key)) {
      baseGroups.set(key, []);
    }
    baseGroups.get(key).push({
      name: style.name,
      baseName: baseName,
      id: style._id,
      isCombo: style.comb === '&',
      css: style.styleLess,
      normalizedCss: normalizeCss(style.styleLess)
    });
  });
  
  // Now find groups where multiple classes have the SAME CSS
  const groups = [];
  
  baseGroups.forEach((styleGroup, baseName) => {
    if (styleGroup.length < 2) return;
    
    // Sub-group by identical CSS
    const cssBuckets = new Map();
    styleGroup.forEach(s => {
      if (!cssBuckets.has(s.normalizedCss)) {
        cssBuckets.set(s.normalizedCss, []);
      }
      cssBuckets.get(s.normalizedCss).push(s);
    });
    
    // Only flag buckets with 2+ classes with DIFFERENT names (same base, same CSS)
    cssBuckets.forEach((bucket, css) => {
      if (bucket.length >= 2) {
        // Check if these are actually different class names, not same class in different contexts
        const uniqueNames = [...new Set(bucket.map(s => s.name))];
        if (uniqueNames.length >= 2) {
          groups.push({
            baseName: baseName,
            styles: bucket.filter((s, i, arr) => arr.findIndex(x => x.name === s.name) === i), // Dedupe by name
            css: bucket[0].css.substring(0, 150),
            count: uniqueNames.length,
            suggestion: `Merge into .${baseName}`
          });
        }
      }
    });
  });
  
  return groups;
}

// ========== STYLE CONSISTENCY ANALYSIS (20 pts) ==========

function analyzeStyleConsistency(aggregated, frameworkConfig) {
  const { allStyles, allCss } = aggregated;
  const issues = [];
  let score = 20;
  
  // 1. Extract and analyze colors
  const colors = extractColors(allStyles);
  const nearDuplicateColors = findNearDuplicateColors(colors.hardcoded);
  
  if (nearDuplicateColors.length > 5) {
    score -= 4;
    issues.push(`${nearDuplicateColors.length} near-duplicate color pairs`);
  } else if (nearDuplicateColors.length > 2) {
    score -= 2;
    issues.push(`${nearDuplicateColors.length} near-duplicate colors`);
  }
  
  // Bonus for CSS variables
  if (colors.variables.length > 10) score = Math.min(20, score + 2);
  else if (colors.variables.length === 0 && colors.hardcoded.length > 10) {
    score -= 2;
    issues.push('No CSS variables used for colors');
  }
  
  // 2. Analyze spacing consistency
  const spacing = extractSpacing(allStyles);
  const spacingAnalysis = analyzeSpacingPatterns(spacing);
  
  if (spacingAnalysis.offScaleRatio > 0.4) {
    score -= 3;
    issues.push(`${Math.round(spacingAnalysis.offScaleRatio * 100)}% spacing off-scale`);
  } else if (spacingAnalysis.offScaleRatio > 0.2) {
    score -= 1;
  }
  
  // Check for suspicious near-duplicate spacing
  if (spacingAnalysis.nearDuplicates.length > 3) {
    score -= 2;
    issues.push(`${spacingAnalysis.nearDuplicates.length} inconsistent spacing pairs`);
  }
  
  // 3. Check spacing in root elements (more strict)
  const rootSpacingIssues = analyzeRootSpacing(aggregated);
  if (rootSpacingIssues.length > 0) {
    score -= Math.min(3, rootSpacingIssues.length);
    issues.push(`Inconsistent root-level spacing`);
  }
  
  return {
    score: Math.max(0, score),
    max: 20,
    detail: `${colors.hardcoded.length} colors, ${spacing.unique.length} spacing values`,
    issues,
    data: { colors, nearDuplicateColors, spacing, spacingAnalysis, rootSpacingIssues }
  };
}

function extractColors(styles) {
  const colorRe = /#[0-9a-fA-F]{3,8}|rgba?\s*\([^)]+\)|hsla?\s*\([^)]+\)/gi;
  const varRe = /var\s*\(\s*--[^)]+\)/gi;
  
  const hardcoded = new Map();
  const variables = new Set();
  
  styles.forEach(style => {
    const css = style.styleLess || '';
    (css.match(colorRe) || []).forEach(c => {
      const normalized = c.toLowerCase().replace(/\s/g, '');
      if (!hardcoded.has(normalized)) {
        hardcoded.set(normalized, { value: normalized, classes: [], rgb: parseColor(normalized) });
      }
      hardcoded.get(normalized).classes.push(style.name);
    });
    (css.match(varRe) || []).forEach(v => variables.add(v));
  });
  
  return {
    hardcoded: Array.from(hardcoded.values()),
    variables: Array.from(variables)
  };
}

function parseColor(color) {
  // Convert color to RGB for comparison
  if (color.startsWith('#')) {
    let hex = color.slice(1);
    if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
    const num = parseInt(hex.substring(0, 6), 16);
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }
  if (color.startsWith('rgb')) {
    const match = color.match(/(\d+)/g);
    if (match && match.length >= 3) {
      return { r: parseInt(match[0]), g: parseInt(match[1]), b: parseInt(match[2]) };
    }
  }
  return null;
}

function colorDistance(c1, c2) {
  if (!c1 || !c2) return 999;
  return Math.sqrt(
    Math.pow(c1.r - c2.r, 2) +
    Math.pow(c1.g - c2.g, 2) +
    Math.pow(c1.b - c2.b, 2)
  );
}

function findNearDuplicateColors(colors) {
  const pairs = [];
  const threshold = 15; // ~5% difference
  
  for (let i = 0; i < colors.length; i++) {
    for (let j = i + 1; j < colors.length; j++) {
      const dist = colorDistance(colors[i].rgb, colors[j].rgb);
      if (dist > 0 && dist < threshold) {
        // Check if class names suggest intentional difference
        const intentional = checkIntentionalColorDiff(colors[i], colors[j]);
        if (!intentional) {
          pairs.push({
            color1: colors[i],
            color2: colors[j],
            distance: dist,
            percentage: Math.round((dist / 441) * 100) // 441 = max distance (white to black)
          });
        }
      }
    }
  }
  
  return pairs;
}

function checkIntentionalColorDiff(c1, c2) {
  // Check if class names suggest these are intentionally different
  const names1 = c1.classes.join(' ').toLowerCase();
  const names2 = c2.classes.join(' ').toLowerCase();
  
  // Intentional patterns: semantic pairs that SHOULD be different
  const intentionalPairs = [
    ['primary', 'secondary'],
    ['hover', 'active'],
    ['light', 'dark'],
    ['muted', 'strong'],
    ['subtle', 'bold'],
    ['foreground', 'background'],
    ['border', 'background'],
    ['text', 'background']
  ];
  
  for (const [a, b] of intentionalPairs) {
    if ((names1.includes(a) && names2.includes(b)) || 
        (names1.includes(b) && names2.includes(a))) {
      return true; // Likely intentional contrast pair
    }
  }
  
  // If one is a hover/focus state, likely intentional
  if ((names1.includes('hover') || names1.includes('focus') || names1.includes('active')) !==
      (names2.includes('hover') || names2.includes('focus') || names2.includes('active'))) {
    return true;
  }
  
  // If class names are very different (not sharing common words), might be intentional
  const words1 = names1.split(/[-_\s]/).filter(w => w.length > 2);
  const words2 = names2.split(/[-_\s]/).filter(w => w.length > 2);
  const sharedWords = words1.filter(w => words2.includes(w));
  
  if (sharedWords.length === 0 && words1.length > 0 && words2.length > 0) {
    return true; // Completely different contexts, might be intentional
  }
  
  // If both use similar semantic names but different colors, likely unintentional
  const similarContexts = ['background', 'bg', 'text', 'color', 'border', 'fill'];
  for (const ctx of similarContexts) {
    if (names1.includes(ctx) && names2.includes(ctx)) {
      return false; // Same context, near-duplicate = unintentional
    }
  }
  
  return false; // Conservative - flag for review
}

function extractSpacing(styles) {
  const spacingRe = /(?:padding|margin|gap)(?:-(?:top|bottom|left|right|inline|block))?:\s*(-?\d+(?:\.\d+)?)(px|rem|em|%)/gi;
  const values = new Map();
  
  styles.forEach(style => {
    const css = style.styleLess || '';
    let match;
    while ((match = spacingRe.exec(css)) !== null) {
      const value = parseFloat(match[1]);
      const unit = match[2];
      const fullProperty = match[0].split(':')[0].trim();
      
      // Get property category (padding, margin, or gap)
      let category = 'other';
      if (fullProperty.startsWith('padding')) category = 'padding';
      else if (fullProperty.startsWith('margin')) category = 'margin';
      else if (fullProperty.includes('gap')) category = 'gap';
      
      // Convert to px for comparison (assuming 16px base)
      let pxValue = value;
      if (unit === 'rem') pxValue = value * 16;
      if (unit === 'em') pxValue = value * 16;
      
      const key = `${pxValue}px`;
      if (!values.has(key)) {
        values.set(key, { value: pxValue, original: `${value}${unit}`, classes: [], properties: [], categories: new Set() });
      }
      const entry = values.get(key);
      if (!entry.classes.includes(style.name)) {
        entry.classes.push(style.name);
      }
      entry.properties.push({ property: fullProperty, class: style.name, category });
      entry.categories.add(category);
    }
  });
  
  return {
    all: Array.from(values.values()),
    unique: Array.from(values.keys()).map(k => values.get(k).value).sort((a, b) => a - b),
    byValue: values
  };
}

function analyzeSpacingPatterns(spacing) {
  const { unique, all, byValue } = spacing;
  
  // Find best matching scale
  let bestScale = null;
  let bestOnScale = 0;
  
  for (const [name, scale] of Object.entries(SPACING_SCALES)) {
    const onScale = unique.filter(v => scale.includes(Math.round(v))).length;
    if (onScale > bestOnScale) {
      bestOnScale = onScale;
      bestScale = name;
    }
  }
  
  const offScaleValues = unique.filter(v => 
    !Object.values(SPACING_SCALES).some(scale => scale.includes(Math.round(v)))
  );
  
  // Get classes for off-scale values
  const offScaleWithClasses = offScaleValues.map(v => {
    const key = `${v}px`;
    const data = byValue?.get(key);
    return {
      value: v,
      classes: data?.classes || []
    };
  });
  
  // Find near-duplicate spacing (e.g., 15px and 16px) - only compare SAME property types
  const nearDuplicates = [];
  for (let i = 0; i < unique.length; i++) {
    for (let j = i + 1; j < unique.length; j++) {
      const diff = Math.abs(unique[i] - unique[j]);
      if (diff > 0 && diff <= 2 && unique[i] > 10) { // Only flag for larger values
        const key1 = `${unique[i]}px`;
        const key2 = `${unique[j]}px`;
        const data1 = byValue?.get(key1);
        const data2 = byValue?.get(key2);
        
        // Only flag if they share at least one property category (padding vs padding, etc)
        const categories1 = data1?.categories || new Set();
        const categories2 = data2?.categories || new Set();
        const sharedCategories = [...categories1].filter(c => categories2.has(c));
        
        if (sharedCategories.length > 0) {
          nearDuplicates.push({ 
            v1: unique[i], 
            v2: unique[j], 
            diff,
            classes1: data1?.classes || [],
            classes2: data2?.classes || [],
            sharedCategory: sharedCategories[0] // e.g., 'padding', 'margin', 'gap'
          });
        }
      }
    }
  }
  
  return {
    bestScale,
    onScaleRatio: bestOnScale / (unique.length || 1),
    offScaleRatio: offScaleValues.length / (unique.length || 1),
    offScaleValues,
    offScaleWithClasses,
    nearDuplicates
  };
}

function analyzeRootSpacing(aggregated) {
  // Find root-level elements (sections, containers) and check spacing consistency
  const { allNodes, allStyles } = aggregated;
  const issues = [];
  
  // Get styles used on section/container type elements
  const rootTypes = ['Section', 'Container'];
  const rootClasses = new Set();
  
  allNodes.forEach(node => {
    if (rootTypes.includes(node.type)) {
      (node.classes || []).forEach(c => rootClasses.add(c));
    }
  });
  
  // Compare padding/margin across these root classes
  const rootStyles = allStyles.filter(s => rootClasses.has(s._id));
  const rootSpacing = {};
  
  rootStyles.forEach(style => {
    const css = style.styleLess || '';
    const paddingMatch = css.match(/padding(?:-[a-z]+)?:\s*(\d+)/);
    if (paddingMatch) {
      const val = parseInt(paddingMatch[1]);
      if (!rootSpacing[style.name]) rootSpacing[style.name] = [];
      rootSpacing[style.name].push(val);
    }
  });
  
  // Check for inconsistencies in root padding
  const rootPaddings = Object.values(rootSpacing).flat();
  const uniqueRootPaddings = [...new Set(rootPaddings)];
  
  if (uniqueRootPaddings.length > 3) {
    issues.push({ type: 'inconsistent', values: uniqueRootPaddings });
  }
  
  return issues;
}

// ========== TYPOGRAPHY ANALYSIS (10 pts) ==========

function analyzeTypography(aggregated) {
  const { allStyles } = aggregated;
  const issues = [];
  let score = 10;
  
  const typography = extractTypography(allStyles);
  
  // Font families
  if (typography.families.size > 4) {
    score -= 3;
    issues.push(`${typography.families.size} different font families`);
  } else if (typography.families.size > 3) {
    score -= 1;
  }
  
  // Font sizes - look for clustering issues
  const sizeAnalysis = analyzeFontSizes(typography.sizes);
  
  if (sizeAnalysis.nearDuplicates.length > 3) {
    score -= 2;
    issues.push(`${sizeAnalysis.nearDuplicates.length} near-duplicate font sizes`);
  }
  
  if (typography.sizes.length > 12) {
    score -= 2;
    issues.push(`${typography.sizes.length} different font sizes`);
  } else if (typography.sizes.length > 8) {
    score -= 1;
  }
  
  // Check for type scale
  if (!sizeAnalysis.hasTypeScale && typography.sizes.length > 4) {
    score -= 1;
    issues.push('No consistent type scale detected');
  }
  
  // Line height consistency
  if (typography.lineHeights.length > 6) {
    score -= 1;
    issues.push(`${typography.lineHeights.length} different line heights`);
  }
  
  return {
    score: Math.max(0, score),
    max: 10,
    detail: `${typography.families.size} fonts, ${typography.sizes.length} sizes`,
    issues,
    data: { typography, sizeAnalysis }
  };
}

function extractTypography(styles) {
  const families = new Set();
  const sizes = [];
  const weights = new Set();
  const lineHeights = [];
  
  styles.forEach(style => {
    const css = style.styleLess || '';
    
    const famMatch = css.match(/font-family:\s*([^;]+)/i);
    if (famMatch) families.add(famMatch[1].trim().toLowerCase());
    
    const sizeMatch = css.match(/font-size:\s*(\d+(?:\.\d+)?)(px|rem|em)/i);
    if (sizeMatch) {
      let px = parseFloat(sizeMatch[1]);
      if (sizeMatch[2] === 'rem') px *= 16;
      sizes.push({ value: px, class: style.name });
    }
    
    const weightMatch = css.match(/font-weight:\s*(\d+|normal|bold)/i);
    if (weightMatch) weights.add(weightMatch[1]);
    
    const lhMatch = css.match(/line-height:\s*(\d+(?:\.\d+)?)/i);
    if (lhMatch) lineHeights.push(parseFloat(lhMatch[1]));
  });
  
  return { families, sizes, weights, lineHeights: [...new Set(lineHeights)] };
}

function analyzeFontSizes(sizes) {
  const unique = [...new Set(sizes.map(s => s.value))].sort((a, b) => a - b);
  
  // Find near-duplicate sizes
  const nearDuplicates = [];
  for (let i = 0; i < unique.length - 1; i++) {
    const diff = unique[i + 1] - unique[i];
    if (diff <= 2 && unique[i] >= 12) {
      nearDuplicates.push({ v1: unique[i], v2: unique[i + 1], diff });
    }
  }
  
  // Check for type scale (consistent ratio)
  let hasTypeScale = false;
  if (unique.length >= 4) {
    const ratios = [];
    for (let i = 0; i < unique.length - 1; i++) {
      ratios.push(unique[i + 1] / unique[i]);
    }
    const avgRatio = ratios.reduce((a, b) => a + b, 0) / ratios.length;
    const consistent = ratios.every(r => Math.abs(r - avgRatio) < 0.15);
    hasTypeScale = consistent && avgRatio >= 1.1 && avgRatio <= 1.5;
  }
  
  return { unique, nearDuplicates, hasTypeScale };
}

// ========== ARCHITECTURE ANALYSIS (20 pts) ==========

function analyzeArchitecture(aggregated, frameworkConfig) {
  const { allNodes, allStyles, pageCount, pages, nodeMap } = aggregated;
  const issues = [];
  let score = 20;
  
  // 1. Nesting depth analysis
  const nestingAnalysis = analyzeNestingDepth(allNodes, nodeMap, allStyles);
  
  if (nestingAnalysis.maxDepth > 10) {
    score -= 4;
    issues.push(`Max nesting depth: ${nestingAnalysis.maxDepth} levels`);
  } else if (nestingAnalysis.maxDepth > 8) {
    score -= 2;
    issues.push(`Deep nesting: ${nestingAnalysis.maxDepth} levels`);
  }
  
  if (nestingAnalysis.emptyWrappers > 5) {
    score -= 2;
    issues.push(`${nestingAnalysis.emptyWrappers} empty wrapper divs`);
  }
  
  // 2. Component/Symbol usage
  const { unlinkedSymbols } = aggregated;
  if (unlinkedSymbols > 5) {
    score -= 3;
    issues.push(`${unlinkedSymbols} unlinked symbols (tech debt)`);
  } else if (unlinkedSymbols > 2) {
    score -= 1;
  }
  
  // 3. Structure consistency across pages
  if (pageCount > 1) {
    const structureConsistency = analyzeStructureConsistency(pages);
    if (structureConsistency.score < 0.5) {
      score -= 3;
      issues.push('Inconsistent page structure');
    } else if (structureConsistency.score < 0.7) {
      score -= 1;
    }
  }
  
  // 4. Root element patterns
  const rootPatterns = analyzeRootPatterns(allNodes, nodeMap);
  if (rootPatterns.inconsistent) {
    score -= 2;
    issues.push('Inconsistent root-level structure');
  }
  
  // 5. CMS indicators
  const cmsAnalysis = analyzeCmsUsage(allNodes, allStyles);
  if (cmsAnalysis.hasCms) {
    // Not a penalty, but note it
  }
  
  return {
    score: Math.max(0, score),
    max: 20,
    detail: `Max depth: ${nestingAnalysis.maxDepth}, ${unlinkedSymbols} unlinked symbols`,
    issues,
    data: { nestingAnalysis, unlinkedSymbols, rootPatterns, cmsAnalysis }
  };
}

// ========== COMPONENT ANALYSIS ==========

function analyzeComponents(aggregated, frameworkConfig) {
  const { allNodes, nodeMap, allStyles, pages, unlinkedSymbols, pageCount } = aggregated;
  let score = 15; // Start with 15, max 15
  const issues = [];
  
  // Build style lookup
  const styleMap = {};
  allStyles.forEach(s => styleMap[s._id] = s);
  
  // 1. Detect if navigation and footer are components
  const navAnalysis = detectNavigation(allNodes, nodeMap, styleMap, pages);
  const footerAnalysis = detectFooter(allNodes, nodeMap, styleMap, pages);
  
  // 2. Count actual components (symbols)
  const componentAnalysis = analyzeComponentUsage(allNodes, pages);
  
  // 3. Detect repeated patterns that should be components
  const patternAnalysis = detectRepeatedPatterns(allNodes, nodeMap, styleMap, pages);
  
  // 4. Check for component variables (introduced Oct 2023)
  const variableAnalysis = analyzeComponentVariables(allStyles, allNodes);
  
  // 5. Check site age for historical context
  const siteAge = detectSiteAge(pages);
  
  // Scoring
  
  // Navigation not a component = serious issue
  if (!navAnalysis.isComponent && navAnalysis.found) {
    score -= 4;
    issues.push('Navigation is not a component');
  }
  
  // Footer not a component = serious issue  
  if (!footerAnalysis.isComponent && footerAnalysis.found) {
    score -= 3;
    issues.push('Footer is not a component');
  }
  
  // Repeated patterns that should be components
  if (patternAnalysis.shouldBeComponents.length > 5) {
    score -= 4;
    issues.push(`${patternAnalysis.shouldBeComponents.length} repeated patterns should be components`);
  } else if (patternAnalysis.shouldBeComponents.length > 2) {
    score -= 2;
    issues.push(`${patternAnalysis.shouldBeComponents.length} repeated patterns could be components`);
  }
  
  // Low component usage across pages
  if (componentAnalysis.totalComponents === 0 && pageCount > 1) {
    score -= 2;
    issues.push('No components detected');
  } else if (componentAnalysis.avgPerPage < 2 && pageCount > 2) {
    score -= 1;
    issues.push('Low component usage');
  }
  
  // Bonus for good practices
  if (variableAnalysis.hasVariables && componentAnalysis.totalComponents > 0) {
    score = Math.min(15, score + 1); // Bonus for using variables
  }
  
  // Build historical context
  let historicalNote = null;
  if (siteAge.estimatedYear && siteAge.estimatedYear < 2023) {
    historicalNote = `Site appears to be from ~${siteAge.estimatedYear}. Component variables weren't available until late 2023.`;
  } else if (siteAge.estimatedYear === 2023 && siteAge.estimatedMonth < 10) {
    historicalNote = `Site appears to be from early 2023. Component variables weren't available until October 2023.`;
  }
  
  return {
    score: Math.max(0, score),
    max: 15,
    detail: `${componentAnalysis.uniqueComponents} unique components, ${componentAnalysis.totalComponents} instances`,
    issues,
    data: {
      navAnalysis,
      footerAnalysis,
      componentAnalysis,
      patternAnalysis,
      variableAnalysis,
      siteAge,
      historicalNote
    }
  };
}

function detectNavigation(allNodes, nodeMap, styleMap, pages) {
  // Look for navigation patterns in the DOM structure
  const navPatterns = {
    found: false,
    isComponent: false,
    instances: [],
    structure: null
  };
  
  // First, find all Symbol nodes and their contents
  const symbolNodes = new Set();
  const symbolContents = new Map(); // symbolId -> child node IDs
  
  allNodes.forEach(node => {
    if (node.type === 'Symbol' || node.type === 'CommerceSymbol' || node.symbolId) {
      symbolNodes.add(node._id);
      // Track what's inside this symbol
      if (node.children) {
        node.children.forEach(childId => {
          symbolContents.set(childId, node._id);
        });
      }
    }
  });
  
  // Helper to check if a node is inside a symbol (at any depth)
  function isInsideSymbol(nodeId, depth = 5) {
    if (depth <= 0) return false;
    if (symbolNodes.has(nodeId)) return true;
    if (symbolContents.has(nodeId)) return true;
    
    // Check if any ancestor is a symbol
    const node = nodeMap[nodeId];
    if (!node) return false;
    
    // Look for parent by checking who has this node as a child
    for (const potentialParent of allNodes) {
      if (potentialParent.children?.includes(nodeId)) {
        if (symbolNodes.has(potentialParent._id) || potentialParent.type === 'Symbol' || potentialParent.symbolId) {
          return true;
        }
        return isInsideSymbol(potentialParent._id, depth - 1);
      }
    }
    return false;
  }
  
  // Group nodes by page
  const pageNodes = {};
  allNodes.forEach(node => {
    if (!pageNodes[node.pageName]) pageNodes[node.pageName] = [];
    pageNodes[node.pageName].push(node);
  });
  
  // Look for nav-like structures on each page
  Object.entries(pageNodes).forEach(([pageName, nodes]) => {
    nodes.forEach(node => {
      const isNav = isNavigationElement(node, nodeMap, styleMap);
      if (isNav.likely) {
        // Check if this nav OR its wrapper is a symbol
        const nodeIsSymbol = node.type === 'Symbol' || node.type === 'CommerceSymbol' || !!node.symbolId;
        const isInSymbol = isInsideSymbol(node._id);
        
        navPatterns.found = true;
        navPatterns.instances.push({
          page: pageName,
          nodeId: node._id,
          type: node.type,
          classes: getClassNames(node, styleMap),
          isSymbol: nodeIsSymbol || isInSymbol,
          confidence: isNav.confidence,
          reason: isNav.reason
        });
      }
    });
  });
  
  // Check if all (or most) instances are components
  if (navPatterns.instances.length > 0) {
    const symbolInstances = navPatterns.instances.filter(i => i.isSymbol);
    // Consider it a component if ANY instances are symbols (they might have different navs for different pages)
    navPatterns.isComponent = symbolInstances.length > 0;
    navPatterns.componentCount = symbolInstances.length;
    navPatterns.nonComponentCount = navPatterns.instances.length - symbolInstances.length;
    
    // Also check if they share a common structure (component-like behavior)
    const structures = navPatterns.instances.map(i => i.classes.join(','));
    const uniqueStructures = [...new Set(structures)];
    if (uniqueStructures.length === 1 && navPatterns.instances.length > 1) {
      navPatterns.isConsistent = true;
    }
  }
  
  return navPatterns;
}

function isNavigationElement(node, nodeMap, styleMap) {
  const classNames = getClassNames(node, styleMap).map(c => c.toLowerCase());
  const type = (node.type || '').toLowerCase();
  const tag = (node.tag || '').toLowerCase();
  
  // If it's a Symbol itself with nav-like naming, it's a nav component
  if (type === 'symbol' || type === 'commercesymbol' || node.symbolId) {
    const navClassPatterns = ['nav', 'navbar', 'header', 'menu', 'topbar', 'navigation'];
    if (classNames.some(c => navClassPatterns.some(p => c.includes(p)))) {
      return { likely: true, confidence: 'high', reason: 'Nav component (Symbol)' };
    }
  }
  
  // Direct indicators
  if (type === 'navbar' || tag === 'nav') {
    return { likely: true, confidence: 'high', reason: 'Nav element type' };
  }
  
  // Class name patterns
  const navClassPatterns = ['nav', 'navbar', 'header', 'menu', 'topbar', 'navigation'];
  if (classNames.some(c => navClassPatterns.some(p => c.includes(p)))) {
    // Check it's not a footer nav
    if (!classNames.some(c => c.includes('footer'))) {
      return { likely: true, confidence: 'medium', reason: 'Nav class pattern' };
    }
  }
  
  // Structure analysis: contains logo + multiple links
  const children = (node.children || []).map(id => nodeMap[id]).filter(Boolean);
  const hasLogo = children.some(c => 
    c.type === 'Image' || 
    getClassNames(c, styleMap).some(cn => cn.toLowerCase().includes('logo'))
  );
  const linkCount = countLinks(node, nodeMap);
  
  if (hasLogo && linkCount >= 3) {
    return { likely: true, confidence: 'medium', reason: 'Logo + multiple links structure' };
  }
  
  return { likely: false };
}

function detectFooter(allNodes, nodeMap, styleMap, pages) {
  const footerPatterns = {
    found: false,
    isComponent: false,
    instances: []
  };
  
  // Find all Symbol nodes
  const symbolNodes = new Set();
  allNodes.forEach(node => {
    if (node.type === 'Symbol' || node.type === 'CommerceSymbol' || node.symbolId) {
      symbolNodes.add(node._id);
    }
  });
  
  // Helper to check if a node is inside a symbol
  function isInsideSymbol(nodeId, depth = 5) {
    if (depth <= 0) return false;
    if (symbolNodes.has(nodeId)) return true;
    
    const node = nodeMap[nodeId];
    if (!node) return false;
    
    for (const potentialParent of allNodes) {
      if (potentialParent.children?.includes(nodeId)) {
        if (symbolNodes.has(potentialParent._id) || potentialParent.type === 'Symbol' || potentialParent.symbolId) {
          return true;
        }
        return isInsideSymbol(potentialParent._id, depth - 1);
      }
    }
    return false;
  }
  
  // Group nodes by page
  const pageNodes = {};
  allNodes.forEach(node => {
    if (!pageNodes[node.pageName]) pageNodes[node.pageName] = [];
    pageNodes[node.pageName].push(node);
  });
  
  Object.entries(pageNodes).forEach(([pageName, nodes]) => {
    nodes.forEach(node => {
      const isFooter = isFooterElement(node, nodeMap, styleMap);
      if (isFooter.likely) {
        const nodeIsSymbol = node.type === 'Symbol' || node.type === 'CommerceSymbol' || !!node.symbolId;
        const isInSymbol = isInsideSymbol(node._id);
        
        footerPatterns.found = true;
        footerPatterns.instances.push({
          page: pageName,
          nodeId: node._id,
          type: node.type,
          classes: getClassNames(node, styleMap),
          isSymbol: nodeIsSymbol || isInSymbol,
          confidence: isFooter.confidence
        });
      }
    });
  });
  
  if (footerPatterns.instances.length > 0) {
    const symbolInstances = footerPatterns.instances.filter(i => i.isSymbol);
    footerPatterns.isComponent = symbolInstances.length > 0;
    footerPatterns.componentCount = symbolInstances.length;
    footerPatterns.nonComponentCount = footerPatterns.instances.length - symbolInstances.length;
  }
  
  return footerPatterns;
}

function isFooterElement(node, nodeMap, styleMap) {
  const classNames = getClassNames(node, styleMap).map(c => c.toLowerCase());
  const type = (node.type || '').toLowerCase();
  const tag = (node.tag || '').toLowerCase();
  
  // If it's a Symbol itself with footer-like naming, it's a footer component
  if (type === 'symbol' || type === 'commercesymbol' || node.symbolId) {
    const footerPatterns = ['footer', 'foot', 'bottom'];
    if (classNames.some(c => footerPatterns.some(p => c.includes(p)))) {
      return { likely: true, confidence: 'high', reason: 'Footer component (Symbol)' };
    }
  }
  
  if (tag === 'footer') {
    return { likely: true, confidence: 'high', reason: 'Footer tag' };
  }
  
  const footerPatterns = ['footer', 'foot', 'bottom-section', 'site-footer'];
  if (classNames.some(c => footerPatterns.some(p => c.includes(p)))) {
    return { likely: true, confidence: 'high', reason: 'Footer class pattern' };
  }
  
  // Check for copyright text indicator in class names
  if (classNames.some(c => c.includes('copyright') || c.includes('legal'))) {
    return { likely: true, confidence: 'medium', reason: 'Copyright section' };
  }
  
  return { likely: false };
}

function analyzeComponentUsage(allNodes, pages) {
  const components = allNodes.filter(n => 
    n.type === 'Symbol' || n.type === 'CommerceSymbol' || n.symbolId
  );
  
  const uniqueSymbols = new Set(components.map(c => c.symbolId || c._id));
  
  // Count per page
  const perPage = {};
  components.forEach(c => {
    if (!perPage[c.pageName]) perPage[c.pageName] = 0;
    perPage[c.pageName]++;
  });
  
  const pageCount = pages.length || 1;
  const avgPerPage = components.length / pageCount;
  
  return {
    totalComponents: components.length,
    uniqueComponents: uniqueSymbols.size,
    avgPerPage,
    perPage
  };
}

function detectRepeatedPatterns(allNodes, nodeMap, styleMap, pages) {
  // Hash structure patterns to find repeated elements
  const patterns = new Map();
  const shouldBeComponents = [];
  
  // Only analyze "significant" structures (3+ children or specific types)
  const significantNodes = allNodes.filter(node => {
    const children = node.children || [];
    const type = (node.type || '').toLowerCase();
    return children.length >= 2 || 
           type.includes('section') || 
           type.includes('container') ||
           type.includes('block');
  });
  
  significantNodes.forEach(node => {
    // Skip if it's already a component
    if (node.type === 'Symbol' || node.type === 'CommerceSymbol') return;
    
    const hash = hashNodeStructure(node, nodeMap, styleMap, 2); // 2 levels deep
    if (!hash) return;
    
    if (!patterns.has(hash)) {
      patterns.set(hash, []);
    }
    patterns.get(hash).push({
      nodeId: node._id,
      page: node.pageName,
      classes: getClassNames(node, styleMap),
      type: node.type,
      childCount: (node.children || []).length
    });
  });
  
  // Find patterns that appear on multiple pages
  patterns.forEach((instances, hash) => {
    const uniquePages = [...new Set(instances.map(i => i.page))];
    
    // If same structure appears on 2+ pages and isn't a component, flag it
    if (uniquePages.length >= 2 && instances.length >= 2) {
      // Get representative class names
      const classPattern = instances[0].classes.slice(0, 3).join(', ');
      shouldBeComponents.push({
        hash,
        instances: instances.slice(0, 5),
        pageCount: uniquePages.length,
        totalCount: instances.length,
        classPattern: classPattern || 'unnamed structure',
        childCount: instances[0].childCount,
        suggestion: `This ${instances[0].type || 'structure'} appears on ${uniquePages.length} pages`
      });
    }
  });
  
  // Sort by frequency
  shouldBeComponents.sort((a, b) => b.totalCount - a.totalCount);
  
  return {
    shouldBeComponents: shouldBeComponents.slice(0, 10),
    totalPatterns: patterns.size
  };
}

function hashNodeStructure(node, nodeMap, styleMap, depth = 2) {
  if (!node || depth < 0) return '';
  
  const type = node.type || 'unknown';
  const tag = node.tag || '';
  const classNames = getClassNames(node, styleMap);
  
  // Create a structural hash (type + child count + class pattern)
  const childIds = node.children || [];
  let childHash = '';
  
  if (depth > 0 && childIds.length > 0) {
    const childHashes = childIds.slice(0, 5).map(id => {
      const child = nodeMap[id];
      return child ? hashNodeStructure(child, nodeMap, styleMap, depth - 1) : '';
    });
    childHash = childHashes.join('|');
  }
  
  // Include class base names (without numbers) for pattern matching
  const classBase = classNames.map(c => c.replace(/[-_]?\d+$/, '').toLowerCase()).sort().join(',');
  
  return `${type}:${tag}:${childIds.length}:${classBase}:${childHash}`;
}

function analyzeComponentVariables(allStyles, allNodes) {
  // Check for CSS variable usage which indicates intentional design
  let hasVariables = false;
  let variableCount = 0;
  
  allStyles.forEach(style => {
    const css = style.styleLess || '';
    const varMatches = css.match(/var\(--[^)]+\)/g);
    if (varMatches) {
      hasVariables = true;
      variableCount += varMatches.length;
    }
  });
  
  // Component variables (properties) would show as variant styles
  // This is harder to detect without full component data
  
  return {
    hasVariables,
    variableCount,
    hasCssVariables: hasVariables
  };
}

function detectSiteAge(pages) {
  // Try to estimate site age from class patterns and Webflow features
  let estimatedYear = null;
  let estimatedMonth = null;
  let indicators = [];
  
  // Look for date patterns in class names (rare but possible)
  // Look for Webflow version indicators
  
  const allClassNames = [];
  pages.forEach(page => {
    page.styles?.forEach(s => allClassNames.push(s.name));
  });
  
  // Check for older Webflow patterns
  const hasOldPatterns = allClassNames.some(c => 
    c?.match(/^w-\d+$/) || // Old Webflow class format
    c?.includes('af-class-') || // Webflow migration classes
    c?.includes('w-condition-')
  );
  
  if (hasOldPatterns) {
    indicators.push('Legacy Webflow class patterns detected');
    estimatedYear = 2020; // Rough estimate
  }
  
  // Check for newer features (components with variants use specific patterns)
  const hasNewPatterns = allClassNames.some(c =>
    c?.match(/^Style\s*\d+$/i) // Component variant styles (2023+)
  );
  
  if (hasNewPatterns) {
    estimatedYear = 2023;
    indicators.push('Component variant styles detected');
  }
  
  return {
    estimatedYear,
    estimatedMonth,
    indicators,
    confidence: indicators.length > 0 ? 'low' : 'none'
  };
}

function getClassNames(node, styleMap) {
  return (node.classes || []).map(c => {
    const style = styleMap[c];
    return style?.name || c;
  }).filter(Boolean);
}

function countLinks(node, nodeMap, depth = 3) {
  if (!node || depth < 0) return 0;
  
  let count = 0;
  if (node.type === 'Link' || node.tag === 'a') count++;
  
  (node.children || []).forEach(childId => {
    const child = nodeMap[childId];
    if (child) count += countLinks(child, nodeMap, depth - 1);
  });
  
  return count;
}

function analyzeNestingDepth(nodes, nodeMap, allStyles) {
  let maxDepth = 0;
  let deepNodes = [];
  let emptyWrappers = 0;
  const emptyWrappersList = [];
  
  // Build style map for class name lookups
  const styleMap = {};
  if (allStyles) {
    allStyles.forEach(s => styleMap[s._id] = s);
  }
  
  function getDepth(nodeId, current = 0, path = []) {
    const node = nodeMap[nodeId];
    if (!node) return current;
    
    // Get class names for this node
    const classNames = (node.classes || []).map(c => {
      const style = styleMap[c];
      return style?.name || c;
    });
    
    const nodeInfo = {
      id: nodeId,
      type: node.type,
      tag: node.tag,
      classes: classNames,
      depth: current,
      path: [...path, { type: node.type, classes: classNames }]
    };
    
    if (current > maxDepth) {
      maxDepth = current;
      deepNodes = [nodeInfo];
    } else if (current === maxDepth && current > 6) {
      deepNodes.push(nodeInfo);
    }
    
    // Check for empty wrapper (div-block with single child and no classes)
    if (node.type === 'Block' && 
        (!node.classes || node.classes.length === 0) && 
        node.children?.length === 1) {
      emptyWrappers++;
      emptyWrappersList.push({
        id: nodeId,
        depth: current,
        childType: nodeMap[node.children[0]]?.type
      });
    }
    
    if (node.children) {
      node.children.forEach(childId => {
        getDepth(childId, current + 1, nodeInfo.path);
      });
    }
    
    return current;
  }
  
  // Find root nodes and traverse
  const childIds = new Set();
  nodes.forEach(n => (n.children || []).forEach(c => childIds.add(c)));
  const rootNodes = nodes.filter(n => !childIds.has(n._id));
  
  rootNodes.forEach(root => getDepth(root._id, 0, []));
  
  return { maxDepth, deepNodes: deepNodes.slice(0, 10), emptyWrappers, emptyWrappersList: emptyWrappersList.slice(0, 20) };
}

function analyzeStructureConsistency(pages) {
  if (pages.length < 2) return { score: 1, details: [] };
  
  // Compare root class patterns across pages
  const pagePatterns = pages.map(page => {
    const roots = page.nodes.filter(n => 
      n.type === 'Section' || n.type === 'Container'
    );
    return {
      name: page.name,
      rootTypes: roots.map(r => r.type),
      rootClassCount: roots.reduce((sum, r) => sum + (r.classes?.length || 0), 0)
    };
  });
  
  // Simple consistency score based on similar root counts
  const avgRootCount = pagePatterns.reduce((sum, p) => sum + p.rootClassCount, 0) / pagePatterns.length;
  const variance = pagePatterns.reduce((sum, p) => sum + Math.pow(p.rootClassCount - avgRootCount, 2), 0) / pagePatterns.length;
  const consistency = 1 / (1 + variance / 100);
  
  return { score: consistency, details: pagePatterns };
}

function analyzeRootPatterns(nodes, nodeMap) {
  const rootTypes = ['Section', 'Container'];
  const patterns = new Map();
  
  nodes.forEach(node => {
    if (rootTypes.includes(node.type)) {
      const pattern = (node.classes || []).sort().join(',');
      if (!patterns.has(pattern)) patterns.set(pattern, 0);
      patterns.set(pattern, patterns.get(pattern) + 1);
    }
  });
  
  // If there are too many unique patterns relative to total, it's inconsistent
  const uniquePatterns = patterns.size;
  const totalRoots = Array.from(patterns.values()).reduce((a, b) => a + b, 0);
  const inconsistent = uniquePatterns > totalRoots * 0.6 && totalRoots > 5;
  
  return { patterns: Array.from(patterns.entries()), inconsistent };
}

function analyzeCmsUsage(nodes, styles) {
  const cmsIndicators = ['Collection', 'CollectionList', 'DynamicWrapper'];
  const hasCms = nodes.some(n => cmsIndicators.includes(n.type));
  
  const cmsClasses = styles.filter(s => 
    s.name.includes('collection') || 
    s.name.includes('cms-') ||
    s.name.includes('dynamic')
  );
  
  return { hasCms, cmsClasses };
}

// ========== MAINTAINABILITY ANALYSIS (15 pts) ==========

function analyzeMaintainability(aggregated, frameworkConfig) {
  const { allStyles, allClassNames, pageCount, pages } = aggregated;
  const issues = [];
  let score = 15;
  
  // 1. Class reuse patterns
  const reuseAnalysis = analyzeClassReuse(allStyles, pageCount);
  
  if (pageCount > 1) {
    if (reuseAnalysis.orphanRatio > 0.6) {
      score -= 3;
      issues.push(`${Math.round(reuseAnalysis.orphanRatio * 100)}% classes used on single page only`);
    } else if (reuseAnalysis.orphanRatio > 0.4) {
      score -= 1;
    }
  }
  
  // 2. Combo class strategy
  const comboAnalysis = analyzeComboClasses(allStyles, frameworkConfig);
  
  if (comboAnalysis.issues.length > 0) {
    score -= Math.min(3, comboAnalysis.issues.length);
    issues.push(...comboAnalysis.issues.slice(0, 2));
  }
  
  // 3. Empty/orphan classes
  const emptyClasses = allStyles.filter(s => !s.styleLess || s.styleLess.trim().length === 0);
  const jsHooks = emptyClasses.filter(s => s.name.startsWith('js-') || s.name.startsWith('w-'));
  const trueEmptyClasses = emptyClasses.filter(s => !s.name.startsWith('js-') && !s.name.startsWith('w-'));
  const trueEmpty = trueEmptyClasses.length;
  
  if (trueEmpty > 10) {
    score -= 2;
    issues.push(`${trueEmpty} empty classes (not JS hooks)`);
  }
  
  // 4. Global class risk
  const globalRisk = assessGlobalClassRisk(allStyles, aggregated.allNodes);
  if (globalRisk.highRisk.length > 10) {
    score -= 2;
    issues.push(`${globalRisk.highRisk.length} high-impact global classes`);
  }
  
  // 5. Semantic naming misuse (Client-First specific)
  if (frameworkConfig?.expectsExplanatoryNames) {
    const misuse = detectSemanticMisuse(allStyles, pages);
    if (misuse.length > 0) {
      score -= Math.min(3, misuse.length);
      issues.push(`${misuse.length} semantic classes used on wrong pages`);
    }
  }
  
  return {
    score: Math.max(0, score),
    max: 15,
    detail: `${Math.round((1 - reuseAnalysis.orphanRatio) * 100)}% reuse, ${comboAnalysis.comboCount} combos`,
    issues,
    data: { reuseAnalysis, comboAnalysis, emptyClasses: trueEmpty, emptyClassList: trueEmptyClasses.map(s => s.name), globalRisk }
  };
}

function analyzeClassReuse(styles, pageCount) {
  if (pageCount <= 1) return { orphanRatio: 0, sharedCount: 0 };
  
  const orphans = styles.filter(s => s.usedOnPages?.length === 1);
  const shared = styles.filter(s => s.usedOnPages?.length > 1);
  
  return {
    orphanRatio: orphans.length / (styles.length || 1),
    sharedCount: shared.length,
    orphans: orphans.map(s => s.name)
  };
}

function analyzeComboClasses(styles, frameworkConfig) {
  const issues = [];
  const combos = styles.filter(s => s.comb === '&');
  const comboRatio = combos.length / (styles.length || 1);
  
  // Check for excessive combos (unless Client-First which expects more)
  if (!frameworkConfig?.expectsExplanatoryNames) {
    if (comboRatio > 0.6) {
      issues.push('Excessive combo class usage (>60%)');
    }
  }
  
  // Check for no combos when expected
  if (frameworkConfig?.expectsUtilityClasses && combos.length < 5 && styles.length > 30) {
    issues.push('Few combo/utility classes for MAST-style framework');
  }
  
  // Check for missing button variants with components
  const buttonBase = styles.find(s => s.name.toLowerCase() === 'button' || s.name.includes('btn'));
  if (buttonBase) {
    const buttonVariants = combos.filter(c => 
      c.name.toLowerCase().includes('button') || c.name.includes('btn')
    );
    if (buttonVariants.length === 0) {
      issues.push('Button found but no button variants/combos');
    }
  }
  
  // NEW: Check for excessive combos on global/generic classes
  const globalClassNames = ['section', 'container', 'wrapper', 'row', 'column', 'grid', 'block'];
  const combosByBase = new Map();
  
  combos.forEach(combo => {
    // Find what base class this combo extends
    // In Webflow, combo classes reference their base via the hierarchy
    const nameLower = combo.name.toLowerCase();
    for (const global of globalClassNames) {
      if (nameLower.includes(global) || nameLower.startsWith(global)) {
        if (!combosByBase.has(global)) combosByBase.set(global, []);
        combosByBase.get(global).push(combo.name);
      }
    }
  });
  
  // Also check base classes that have many combos applied to them
  const baseClasses = styles.filter(s => s.comb !== '&');
  const globalBases = baseClasses.filter(s => 
    globalClassNames.includes(s.name.toLowerCase())
  );
  
  const globalComboWarnings = [];
  globalBases.forEach(base => {
    // Count combos that might be modifying this base
    const relatedCombos = combos.filter(c => {
      const cName = c.name.toLowerCase();
      const bName = base.name.toLowerCase();
      return cName.includes(bName) || cName.startsWith(bName);
    });
    
    if (relatedCombos.length > 8) {
      globalComboWarnings.push({
        base: base.name,
        comboCount: relatedCombos.length,
        combos: relatedCombos.map(c => c.name)
      });
      issues.push(`${base.name} has ${relatedCombos.length} combo variations - consider componentizing`);
    }
  });
  
  return { comboCount: combos.length, comboRatio, issues, globalComboWarnings };
}

function assessGlobalClassRisk(styles, nodes) {
  const classUsage = new Map();
  
  nodes.forEach(node => {
    (node.classes || []).forEach(classId => {
      if (!classUsage.has(classId)) classUsage.set(classId, 0);
      classUsage.set(classId, classUsage.get(classId) + 1);
    });
  });
  
  // Expected framework/utility classes - these are MEANT to be used everywhere
  const expectedPatterns = [
    /^u-/, /^cc-/, /^c-/, /^l-/, /^is-/, /^has-/,
    /^col/, /^row/, /^slot/, /^page-/,
    /^padding-/, /^margin-/, /^text-size-/, /^text-color-/,
    /^nav/, /^footer/, /^header/, /^menu/,
    /^w-/, /^flex/, /^grid-/, /^gap-/
  ];
  
  function isExpectedUtility(name) {
    const lower = name.toLowerCase();
    return expectedPatterns.some(p => p.test(lower));
  }
  
  const highRisk = [];
  const globalNames = ['section', 'container', 'wrapper', 'button', 'heading', 'text', 'image', 'link'];
  
  styles.forEach(style => {
    const usage = classUsage.get(style._id) || 0;
    const lower = style.name.toLowerCase();
    
    // Skip expected utility/framework classes
    if (isExpectedUtility(style.name)) return;
    
    const isGlobalName = globalNames.some(g => lower === g);
    
    // Only flag if it's a truly generic base that's custom (not utility)
    if (usage > 20 && !isExpectedUtility(style.name)) {
      highRisk.push({
        name: style.name,
        usage,
        reason: 'Very high usage - changes affect many elements'
      });
    } else if (isGlobalName && usage > 8) {
      highRisk.push({
        name: style.name,
        usage,
        reason: 'Generic base class'
      });
    }
  });
  
  return { highRisk: highRisk.sort((a, b) => b.usage - a.usage) };
}

function detectSemanticMisuse(styles, pages) {
  const misuse = [];
  const pageSpecificPatterns = /-(home|about|contact|services|blog|pricing|faq|team|portfolio|industry)/i;
  
  styles.forEach(style => {
    const match = style.name.match(pageSpecificPatterns);
    if (match && style.usedOnPages?.length > 1) {
      const expectedPage = match[1].toLowerCase();
      const wrongPages = style.usedOnPages.filter(p => 
        !p.toLowerCase().includes(expectedPage)
      );
      if (wrongPages.length > 0) {
        misuse.push({
          class: style.name,
          expectedPage,
          foundOn: wrongPages
        });
      }
    }
  });
  
  return misuse;
}

// ========== TECHNICAL PATTERNS ANALYSIS (15 pts) ==========

function analyzeTechnical(aggregated) {
  const { allStyles, allNodes, allInteractions } = aggregated;
  const issues = [];
  let score = 15;
  
  // 1. Breakpoint consistency
  const breakpointAnalysis = analyzeBreakpoints(allStyles);
  if (breakpointAnalysis.inconsistentCount > 10) {
    score -= 3;
    issues.push(`${breakpointAnalysis.inconsistentCount} breakpoint inconsistencies`);
  } else if (breakpointAnalysis.inconsistentCount > 5) {
    score -= 1;
  }
  
  // Bonus for consistent responsive ratio
  if (breakpointAnalysis.hasConsistentRatio) {
    score = Math.min(15, score + 1);
  }
  
  // Flag specific breakpoint issues
  if (breakpointAnalysis.breakpointIssues.length > 0) {
    const mobileIssues = breakpointAnalysis.breakpointIssues.filter(i => 
      i.issue.includes('Mobile')
    );
    if (mobileIssues.length > 3) {
      issues.push(`${mobileIssues.length} mobile spacing issues`);
    }
  }
  
  // 2. Position/overflow patterns
  const positionAnalysis = analyzePositioning(allStyles);
  
  if (positionAnalysis.absoluteCount > 15) {
    score -= 2;
    issues.push(`Excessive absolute positioning (${positionAnalysis.absoluteCount})`);
  }
  
  if (positionAnalysis.zIndexChaos) {
    score -= 2;
    issues.push('Z-index chaos detected');
  }
  
  if (positionAnalysis.overflowHiddenCount > 10) {
    score -= 1;
    issues.push(`Many overflow:hidden (${positionAnalysis.overflowHiddenCount})`);
  }
  
  // 3. State class consistency
  const stateAnalysis = analyzeStateClasses(allStyles);
  if (stateAnalysis.inconsistent) {
    score -= 1;
    issues.push('Inconsistent state class naming');
  }
  
  // 4. Interaction complexity
  if (allInteractions.length > 20) {
    issues.push(`${allInteractions.length} interactions (high maintenance)`);
  }
  
  // Check for interaction reuse
  const uniqueInteractions = new Set(allInteractions.map(i => i.name || i._id));
  if (allInteractions.length > 10 && uniqueInteractions.size === allInteractions.length) {
    score -= 1;
    issues.push('No interaction reuse detected');
  }
  
  return {
    score: Math.max(0, score),
    max: 15,
    detail: `${positionAnalysis.absoluteCount} absolute, ${allInteractions.length} interactions`,
    issues,
    data: { breakpointAnalysis, positionAnalysis, stateAnalysis, interactionCount: allInteractions.length }
  };
}

function analyzeBreakpoints(styles) {
  let inconsistentCount = 0;
  const breakpointPatterns = {};
  const breakpointIssues = [];
  
  // Track spacing progressions across breakpoints
  const spacingProgressions = [];
  
  styles.forEach(style => {
    if (style.variants) {
      const variantKeys = Object.keys(style.variants);
      variantKeys.forEach(vk => {
        if (!breakpointPatterns[vk]) breakpointPatterns[vk] = 0;
        breakpointPatterns[vk]++;
        
        // Check for inconsistent values at breakpoints
        const baseCss = style.styleLess || '';
        const variantCss = style.variants[vk].styleLess || '';
        
        // Extract all padding/margin values
        const baseSpacing = extractSpacingValues(baseCss);
        const variantSpacing = extractSpacingValues(variantCss);
        
        // Check if variant follows expected pattern (smaller on smaller screens)
        const isSmallBreakpoint = vk.includes('small') || vk.includes('tiny') || vk.includes('mobile');
        const isMediumBreakpoint = vk.includes('medium') || vk.includes('tablet');
        
        if (baseSpacing.length > 0 && variantSpacing.length > 0) {
          const baseMax = Math.max(...baseSpacing);
          const variantMax = Math.max(...variantSpacing);
          
          // For small breakpoints, spacing should generally decrease or stay same
          if (isSmallBreakpoint && variantMax > baseMax * 1.2) {
            inconsistentCount++;
            breakpointIssues.push({
              class: style.name,
              issue: 'Mobile spacing larger than desktop',
              base: baseMax,
              variant: variantMax,
              breakpoint: vk
            });
          }
          
          // Track progressions for pattern analysis
          spacingProgressions.push({
            class: style.name,
            base: baseMax,
            variant: variantMax,
            breakpoint: vk,
            ratio: variantMax / baseMax
          });
        }
        
        // Check for non-scale values at breakpoints
        for (const val of variantSpacing) {
          const isOnScale = Object.values(SPACING_SCALES).some(scale => 
            scale.includes(Math.round(val))
          );
          if (!isOnScale && val > 0 && val !== Math.round(val)) {
            // Odd values like 47px, 31px suggest manual adjustments
            inconsistentCount++;
            breakpointIssues.push({
              class: style.name,
              issue: `Off-scale value ${val}px at ${vk}`,
              value: val,
              breakpoint: vk
            });
          }
        }
      });
    }
  });
  
  // Analyze if there's a consistent responsive ratio
  let hasConsistentRatio = false;
  if (spacingProgressions.length >= 3) {
    const ratios = spacingProgressions
      .filter(p => p.ratio > 0 && p.ratio < 2)
      .map(p => p.ratio);
    
    if (ratios.length >= 3) {
      const avgRatio = ratios.reduce((a, b) => a + b, 0) / ratios.length;
      const consistent = ratios.filter(r => Math.abs(r - avgRatio) < 0.2).length;
      hasConsistentRatio = consistent / ratios.length > 0.6;
    }
  }
  
  return { 
    breakpointPatterns, 
    inconsistentCount, 
    breakpointIssues: breakpointIssues.slice(0, 10),
    hasConsistentRatio,
    spacingProgressions
  };
}

function extractSpacingValues(css) {
  const values = [];
  const re = /(?:padding|margin|gap)(?:-[a-z]+)?:\s*(-?\d+(?:\.\d+)?)/gi;
  let match;
  while ((match = re.exec(css)) !== null) {
    values.push(parseFloat(match[1]));
  }
  return values;
}

function analyzePositioning(styles) {
  let absoluteCount = 0;
  let fixedCount = 0;
  let overflowHiddenCount = 0;
  const zIndexValues = [];
  
  styles.forEach(style => {
    const css = style.styleLess || '';
    
    if (css.includes('position: absolute') || css.includes('position:absolute')) {
      absoluteCount++;
    }
    if (css.includes('position: fixed') || css.includes('position:fixed')) {
      fixedCount++;
    }
    if (css.includes('overflow: hidden') || css.includes('overflow:hidden')) {
      overflowHiddenCount++;
    }
    
    const zMatch = css.match(/z-index:\s*(\d+)/);
    if (zMatch) zIndexValues.push(parseInt(zMatch[1]));
  });
  
  // Z-index chaos: extreme values or too many unique values
  const uniqueZ = [...new Set(zIndexValues)].sort((a, b) => a - b);
  const zIndexChaos = uniqueZ.some(z => z > 100) || uniqueZ.length > 8;
  
  return { absoluteCount, fixedCount, overflowHiddenCount, zIndexValues: uniqueZ, zIndexChaos };
}

function analyzeStateClasses(styles) {
  const statePatterns = {
    'is-': [],
    'has-': [],
    'active': [],
    'hover': [],
    'current': [],
    'open': [],
    'closed': []
  };
  
  styles.forEach(style => {
    const name = style.name.toLowerCase();
    for (const pattern of Object.keys(statePatterns)) {
      if (name.includes(pattern)) {
        statePatterns[pattern].push(style.name);
        break;
      }
    }
  });
  
  // Check if multiple patterns are used
  const usedPatterns = Object.entries(statePatterns).filter(([k, v]) => v.length > 0);
  const inconsistent = usedPatterns.length > 3;
  
  return { statePatterns, inconsistent, usedPatterns };
}

// ========== SCORING HELPERS ==========

function calculateIntentionality(aggregated, metrics) {
  let intentional = 0;
  let unintentional = 0;
  
  // Intentional signals
  const { allStyles } = aggregated;
  const hasVariables = metrics.styleConsistency.data.colors.variables.length > 5;
  const hasConsistentNaming = metrics.naming.data.conventions.mixed < 2;
  const hasGoodSpacing = metrics.styleConsistency.data.spacingAnalysis.onScaleRatio > 0.7;
  const hasFramework = aggregated.framework !== null;
  const hasComponents = aggregated.unlinkedSymbols < 3;
  const hasLowNesting = metrics.architecture.data.nestingAnalysis.maxDepth < 8;
  
  if (hasVariables) intentional += 15;
  if (hasConsistentNaming) intentional += 20;
  if (hasGoodSpacing) intentional += 15;
  if (hasFramework) intentional += 15;
  if (hasComponents) intentional += 10;
  if (hasLowNesting) intentional += 10;
  
  // Unintentional signals
  const autoGenRatio = Object.values(metrics.naming.data.autoGenerated).flat().length / allStyles.length;
  const nearDupColors = metrics.styleConsistency.data.nearDuplicateColors.length;
  const nearDupSpacing = metrics.styleConsistency.data.spacingAnalysis.nearDuplicates.length;
  const duplicateStyles = metrics.naming.data.duplicateCss.length;
  
  unintentional += autoGenRatio * 30;
  unintentional += Math.min(nearDupColors * 3, 15);
  unintentional += Math.min(nearDupSpacing * 3, 10);
  unintentional += Math.min(duplicateStyles * 2, 10);
  
  const total = intentional + unintentional;
  const score = total > 0 ? Math.round((intentional / total) * 100) : 50;
  
  return Math.min(100, Math.max(0, score));
}

function determineComplexity(score, aggregated, metrics) {
  if (score >= 80) return { level: 'Easy', color: '#22c55e', desc: 'Project is well-organized and ready for retainer work' };
  if (score >= 65) return { level: 'Moderate', color: '#fbbf24', desc: 'Some cleanup needed before retainer work' };
  if (score >= 45) return { level: 'Challenging', color: '#f97316', desc: 'Significant issues require attention' };
  return { level: 'Major Refactor', color: '#ef4444', desc: 'Consider rebuilding rather than patching' };
}

function getGrade(score) {
  // Max score is now 115 (was 100), normalize to percentage
  const pct = (score / 115) * 100;
  if (pct >= 90) return 'A+';
  if (pct >= 85) return 'A';
  if (pct >= 80) return 'B+';
  if (pct >= 70) return 'B';
  if (pct >= 60) return 'C';
  if (pct >= 50) return 'D';
  return 'F';
}

// ========== FINDINGS & RECOMMENDATIONS ==========

function generateFindings(aggregated, metrics) {
  return {
    duplicateStyles: metrics.naming.data.duplicateCss.slice(0, 10),
    nearDuplicateColors: metrics.styleConsistency.data.nearDuplicateColors.slice(0, 10),
    spacingIssues: metrics.styleConsistency.data.spacingAnalysis.nearDuplicates.slice(0, 10),
    autoGenerated: Object.entries(metrics.naming.data.autoGenerated)
      .flatMap(([severity, items]) => items.map(i => ({ ...i, severity })))
      .slice(0, 20),
    nestingIssues: metrics.architecture.data.nestingAnalysis,
    positioningIssues: metrics.technical.data.positionAnalysis,
    breakpointIssues: metrics.technical.data.breakpointAnalysis.breakpointIssues || [],
    globalComboWarnings: metrics.maintainability.data.comboAnalysis.globalComboWarnings || []
  };
}

function generateRecommendations(metrics, findings, framework) {
  const recommendations = [];
  
  // Critical issues first
  if (findings.autoGenerated.filter(a => a.severity === 'critical').length > 0) {
    recommendations.push({
      priority: 'critical',
      title: 'Remove copied classes',
      desc: 'Classes with "-copy" indicate duplicated elements. Consolidate these into reusable components.',
      impact: 'High maintenance burden and inconsistency risk'
    });
  }
  
  if (findings.duplicateStyles.length > 5) {
    recommendations.push({
      priority: 'high',
      title: 'Consolidate duplicate styles',
      desc: `${findings.duplicateStyles.length} class groups have identical CSS. Merge into single classes.`,
      impact: 'Reduces class count and simplifies updates'
    });
  }
  
  if (findings.nearDuplicateColors.length > 3) {
    recommendations.push({
      priority: 'high',
      title: 'Standardize colors',
      desc: `${findings.nearDuplicateColors.length} color pairs are nearly identical. Create CSS variables for brand colors.`,
      impact: 'Ensures brand consistency and easier updates'
    });
  }
  
  if (metrics.architecture.data.nestingAnalysis.maxDepth > 8) {
    recommendations.push({
      priority: 'high',
      title: 'Reduce nesting depth',
      desc: `Max nesting is ${metrics.architecture.data.nestingAnalysis.maxDepth} levels. Flatten structure where possible.`,
      impact: 'Improves performance and maintainability'
    });
  }
  
  // Global combo warnings - high priority
  if (findings.globalComboWarnings && findings.globalComboWarnings.length > 0) {
    recommendations.push({
      priority: 'high',
      title: 'Componentize heavily-modified global classes',
      desc: `Classes like .${findings.globalComboWarnings[0].base} have ${findings.globalComboWarnings[0].comboCount}+ combos. Create dedicated components instead.`,
      impact: 'Reduces side-effect risk when making changes'
    });
  }
  
  // Breakpoint issues
  if (findings.breakpointIssues && findings.breakpointIssues.length > 3) {
    recommendations.push({
      priority: 'medium',
      title: 'Fix responsive spacing inconsistencies',
      desc: `${findings.breakpointIssues.length} classes have unexpected responsive behavior (e.g., mobile spacing larger than desktop).`,
      impact: 'Predictable responsive behavior'
    });
  }
  
  if (findings.autoGenerated.filter(a => a.severity === 'high').length > 5) {
    recommendations.push({
      priority: 'medium',
      title: 'Rename auto-generated classes',
      desc: 'Multiple numbered classes like "div-block-2" exist. Give semantic names.',
      impact: 'Makes project more understandable'
    });
  }
  
  if (findings.spacingIssues.length > 2) {
    recommendations.push({
      priority: 'medium',
      title: 'Standardize spacing',
      desc: 'Near-duplicate spacing values found. Align to a consistent scale.',
      impact: 'Visual consistency and easier updates'
    });
  }
  
  if (metrics.technical.data.positionAnalysis.zIndexChaos) {
    recommendations.push({
      priority: 'medium',
      title: 'Organize z-index values',
      desc: 'Z-index values are chaotic. Establish a layering system.',
      impact: 'Prevents stacking issues'
    });
  }
  
  if (!framework && metrics.naming.data.conventions.mixed > 2) {
    recommendations.push({
      priority: 'low',
      title: 'Adopt consistent naming convention',
      desc: 'Mixed naming patterns detected. Consider adopting a framework or standard.',
      impact: 'Long-term maintainability'
    });
  }
  
  return recommendations;
}

function generateQuickWins(metrics, findings) {
  const wins = [];
  
  // Prioritize by effort/impact ratio
  if (findings.autoGenerated.filter(a => a.severity === 'critical').length > 0) {
    wins.push('Rename "-copy" classes with semantic names (5-10 min each)');
  }
  
  if (metrics.styleConsistency.data.colors.variables.length === 0 && 
      metrics.styleConsistency.data.colors.hardcoded.length > 5) {
    wins.push('Create CSS variables for your 3-5 main brand colors');
  }
  
  if (findings.duplicateStyles.length > 0) {
    wins.push(`Merge ${Math.min(3, findings.duplicateStyles.length)} duplicate style groups`);
  }
  
  if (metrics.architecture.data.nestingAnalysis.emptyWrappers > 3) {
    wins.push(`Remove ${metrics.architecture.data.nestingAnalysis.emptyWrappers} empty wrapper divs`);
  }
  
  if (findings.autoGenerated.filter(a => a.severity === 'high').length > 0) {
    wins.push('Rename numbered classes (div-block-2 ‚Üí card-wrapper)');
  }
  
  if (findings.breakpointIssues && findings.breakpointIssues.length > 0) {
    wins.push('Review mobile spacing that exceeds desktop values');
  }
  
  if (findings.globalComboWarnings && findings.globalComboWarnings.length > 0) {
    wins.push(`Consider making .${findings.globalComboWarnings[0].base} a component with variants`);
  }
  
  return wins.slice(0, 5);
}

function generateRiskAssessment(aggregated) {
  const { allStyles, allNodes } = aggregated;
  const classUsage = new Map();
  
  allNodes.forEach(node => {
    (node.classes || []).forEach(classId => {
      if (!classUsage.has(classId)) classUsage.set(classId, { count: 0, pages: new Set() });
      classUsage.get(classId).count++;
      classUsage.get(classId).pages.add(node.pageName);
    });
  });
  
  // Expected framework/utility classes that SHOULD be used many times
  // These are intentionally reusable and not risks
  const expectedHighUsage = [
    // MAST patterns
    /^u-/, /^cc-/, /^c-/, /^l-/, /^is-/, /^has-/,
    /^col$/, /^col-/, /^row$/, /^row-/,
    /^slot/, /^page-wrapper/, /^page-main/,
    // Client-First patterns
    /^padding-/, /^margin-/, /^text-size-/, /^text-color-/,
    /^background-color-/, /^heading-style-/, /^text-style-/,
    /^spacer-/, /^max-width-/, /^hide-/,
    // Common utility patterns
    /^w-/, /^h-/, /^flex/, /^grid-/, /^gap-/,
    /^overflow-/, /^position-/, /^z-/,
    // Navigation/common components (expected everywhere)
    /^nav/, /^navbar/, /^footer/, /^header/,
    /^menu/, /^logo/, /^brand/,
    // Webflow native
    /^w-nav/, /^w-dropdown/, /^w-slider/, /^w-tab/, /^w-form/,
    // State classes
    /^active$/, /^current$/, /^open$/, /^closed$/,
    /^visible$/, /^hidden$/, /^show$/, /^hide$/
  ];
  
  function isExpectedHighUsage(name) {
    const lower = name.toLowerCase();
    return expectedHighUsage.some(pattern => pattern.test(lower));
  }
  
  const risks = [];
  
  // Track if we detected a framework to adjust expectations
  const detectedFramework = detectFramework(allStyles.map(s => s.name));
  
  allStyles.forEach(style => {
    const usage = classUsage.get(style._id);
    if (!usage) return;
    
    const name = style.name;
    const lower = name.toLowerCase();
    
    // Skip if it's an expected high-usage class
    if (isExpectedHighUsage(name)) return;
    
    const isHighUsage = usage.count > 15;
    const isMultiPage = usage.pages.size > 1;
    
    // Only flag generic names that aren't part of a framework pattern
    const genericNames = ['section', 'container', 'wrapper', 'button', 'card', 'block', 'item', 'content', 'text', 'image', 'icon', 'link'];
    const isGenericBase = genericNames.some(g => lower === g);
    
    // Check if this looks like a custom class that's heavily used
    // (not a utility, not framework, but used everywhere)
    const looksCustom = !lower.includes('-') || 
      (lower.split('-').length <= 2 && !isExpectedHighUsage(name));
    
    if (isHighUsage && looksCustom) {
      // Only add if it's truly risky - a custom class used many places
      risks.push({
        name: style.name,
        usage: usage.count,
        pages: usage.pages.size,
        reason: isGenericBase ? 'Generic base class' : 'Custom class with high usage'
      });
    } else if (isGenericBase && usage.count > 5 && !detectedFramework) {
      // Generic names in non-framework projects are higher risk
      risks.push({
        name: style.name,
        usage: usage.count,
        pages: usage.pages.size,
        reason: 'Generic name - modifications affect many elements'
      });
    }
  });
  
  // Filter to only truly concerning classes
  return risks
    .filter(r => r.usage > 8 || r.pages > 2) // Must be used enough to matter
    .sort((a, b) => (b.usage * b.pages) - (a.usage * a.pages)) // Sort by impact
    .slice(0, 8);
}

function generateBrief(aggregated, metrics, framework, complexity, findings) {
  const { pageCount, totalElements, allStyles, allInteractions } = aggregated;
  
  let brief = `<p>This analysis covers <strong>${pageCount} page${pageCount > 1 ? 's' : ''}</strong> `;
  brief += `containing <strong>${totalElements} elements</strong> and <strong>${allStyles.length} classes</strong>. `;
  
  if (framework) {
    brief += `The project uses the <strong>${framework}</strong> framework. `;
  } else {
    brief += `No established framework was detected. `;
  }
  
  brief += `</p>`;
  
  // Overall assessment
  brief += `<p>`;
  if (complexity.level === 'Easy') {
    brief += `The project demonstrates <strong>professional development patterns</strong>. `;
    brief += `Class naming is intentional, spacing follows a system, and the structure is maintainable. `;
    brief += `This project is suitable for retainer work with minimal preparation.`;
  } else if (complexity.level === 'Moderate') {
    brief += `The project has a <strong>reasonable foundation</strong> but shows some inconsistencies. `;
    brief += `Before starting retainer work, address the priority recommendations below. `;
    brief += `Estimated cleanup: 2-4 hours.`;
  } else if (complexity.level === 'Challenging') {
    brief += `The project has <strong>significant technical debt</strong>. `;
    brief += `Multiple issues will make ongoing development slow and risky. `;
    brief += `Consider a cleanup sprint before accepting retainer work. Estimated effort: 1-2 days.`;
  } else {
    brief += `The project has <strong>fundamental issues</strong> that indicate ad-hoc development. `;
    brief += `Modifications are high-risk and time-consuming. `;
    brief += `Recommend discussing a rebuild vs. patch approach with the client.`;
  }
  brief += `</p>`;
  
  // Key concerns
  const concerns = [];
  if (findings.autoGenerated.filter(a => a.severity === 'critical').length > 0) {
    concerns.push('copied classes indicating poor reuse');
  }
  if (findings.nearDuplicateColors.length > 3) {
    concerns.push('inconsistent colors suggesting no design system');
  }
  if (metrics.architecture.data.nestingAnalysis.maxDepth > 8) {
    concerns.push('excessive nesting making structure hard to follow');
  }
  if (metrics.technical.data.positionAnalysis.zIndexChaos) {
    concerns.push('z-index chaos indicating layout workarounds');
  }
  
  if (concerns.length > 0) {
    brief += `<p><strong>Key concerns:</strong> ${concerns.join(', ')}.</p>`;
  }
  
  // Interactions note
  if (allInteractions.length > 10) {
    brief += `<p>Note: This project has <strong>${allInteractions.length} interactions</strong> which adds to the maintenance surface area.</p>`;
  }
  
  return brief;
}

// ========== DISPLAY RESULTS ==========

function displayResults() {
  els.pasteZone.classList.add('hidden');
  els.collectedSection.classList.add('hidden');
  els.resultsSection.classList.remove('hidden');

  const r = analysisResult;
  const color = r.score >= 70 ? '#22c55e' : r.score >= 50 ? '#fbbf24' : '#ef4444';

  // Score circle
  const circ = 2 * Math.PI * 65;
  els.scoreProgress.style.strokeDashoffset = circ - (r.score / 100) * circ;
  els.scoreProgress.style.stroke = color;
  els.scoreValue.textContent = r.score;
  els.scoreValue.style.color = color;
  
  // Grade & Complexity
  els.gradeBadge.textContent = `Grade: ${r.grade}`;
  els.gradeBadge.style.background = `${color}20`;
  els.gradeBadge.style.color = color;
  
  els.complexityBadge.textContent = r.complexity.level;
  els.complexityBadge.style.background = `${r.complexity.color}20`;
  els.complexityBadge.style.color = r.complexity.color;
  
  els.verdictText.textContent = r.complexity.desc;
  
  // Framework
  if (r.framework) {
    els.frameworkBadge.textContent = `‚úì ${r.framework}`;
    els.frameworkBadge.className = 'framework-badge detected';
  } else {
    els.frameworkBadge.textContent = 'Custom approach (no framework)';
    els.frameworkBadge.className = 'framework-badge none';
  }
  
  // Intentionality
  const intColor = r.intentionality >= 70 ? '#22c55e' : r.intentionality >= 50 ? '#fbbf24' : '#ef4444';
  els.intentionalityValue.textContent = `${r.intentionality}%`;
  els.intentionalityValue.style.color = intColor;
  els.intentionalityFill.style.width = `${r.intentionality}%`;
  els.intentionalityFill.style.background = intColor;

  // Metrics grid
  const metricMeta = {
    naming: { 
      icon: 'üìù', 
      label: 'Naming Quality',
      tooltip: `<strong>How we measure naming:</strong>
        <ul>
          <li>Auto-generated classes (div-block, text-block-2)</li>
          <li>Copied classes (-copy, copy-of-)</li>
          <li>Numbered duplicates with identical CSS</li>
          <li>Naming convention consistency</li>
        </ul>
        Severity: Copied = critical, Numbered = high, Generic = medium`
    },
    styleConsistency: { 
      icon: 'üé®', 
      label: 'Style Consistency',
      tooltip: `<strong>How we measure style consistency:</strong>
        <ul>
          <li>Near-duplicate colors (~5% difference)</li>
          <li>CSS variables usage (intentionality)</li>
          <li>Spacing values following a scale (4px/8px)</li>
          <li>Root-level spacing consistency</li>
        </ul>
        Variables = intentional design system`
    },
    typography: { 
      icon: 'üî§', 
      label: 'Typography',
      tooltip: `<strong>How we measure typography:</strong>
        <ul>
          <li>Number of font families (ideal: ‚â§3)</li>
          <li>Font size variations (ideal: ‚â§8)</li>
          <li>Near-duplicate sizes (14px vs 15px)</li>
          <li>Type scale consistency (1.2x, 1.25x ratio)</li>
        </ul>
        Fewer sizes = intentional type system`
    },
    architecture: { 
      icon: 'üèóÔ∏è', 
      label: 'Architecture',
      tooltip: `<strong>How we measure architecture:</strong>
        <ul>
          <li>Nesting depth (ideal: ‚â§6-8 levels)</li>
          <li>Empty wrapper divs (no class, single child)</li>
          <li>Unlinked symbols (broken components)</li>
          <li>Structure consistency across pages</li>
        </ul>
        Deep nesting = hard to maintain`
    },
    components: { 
      icon: 'üß©', 
      label: 'Components',
      tooltip: `<strong>How we measure component usage:</strong>
        <ul>
          <li>Navigation as a component (critical)</li>
          <li>Footer as a component (critical)</li>
          <li>Repeated patterns across pages</li>
          <li>Component variable usage</li>
          <li>Overall component adoption</li>
        </ul>
        Components = consistent, maintainable site`
    },
    maintainability: { 
      icon: 'üîß', 
      label: 'Maintainability',
      tooltip: `<strong>How we measure maintainability:</strong>
        <ul>
          <li>Class reuse across pages</li>
          <li>Combo class strategy</li>
          <li>Button/component variants</li>
          <li>Empty classes (not JS hooks)</li>
          <li>Semantic class misuse</li>
        </ul>
        Higher reuse = easier updates`
    },
    technical: { 
      icon: '‚öôÔ∏è', 
      label: 'Technical',
      tooltip: `<strong>How we measure technical quality:</strong>
        <ul>
          <li>Breakpoint consistency</li>
          <li>Position:absolute count</li>
          <li>Z-index chaos (values >100)</li>
          <li>Overflow:hidden overuse</li>
          <li>Interaction complexity & reuse</li>
        </ul>
        Band-aid fixes = risky changes`
    }
  };
  
  els.metricsGrid.innerHTML = Object.entries(r.metrics).map(([key, m]) => {
    const pct = (m.score / m.max) * 100;
    const c = pct >= 70 ? '#22c55e' : pct >= 40 ? '#fbbf24' : '#ef4444';
    const cls = pct >= 70 ? 'good' : pct >= 40 ? 'warning' : 'bad';
    const meta = metricMeta[key] || { icon: 'üìä', label: key, tooltip: '' };
    
    let issuesHtml = '';
    if (m.issues && m.issues.length > 0) {
      issuesHtml = `<div class="metric-issues">${m.issues.slice(0, 2).map((issue, idx) => 
        `<div class="metric-issue" data-issue-type="${key}-${idx}" onclick="showIssueModal('${key}-${idx}')">${escapeHtml(issue)}</div>`
      ).join('')}</div>`;
    }
    
    return `
      <div class="metric-card">
        <div class="metric-header">
          <span class="tooltip-trigger">
            <span class="metric-title">${meta.icon} ${meta.label}</span>
            <span class="tooltip-icon">?</span>
          </span>
          <div class="tooltip-content">${meta.tooltip}</div>
          <span class="metric-score ${cls}">${m.score}/${m.max}</span>
        </div>
        <div class="metric-bar"><div class="metric-fill" style="width:${pct}%;background:${c}"></div></div>
        <div class="metric-detail">${m.detail}</div>
        ${issuesHtml}
      </div>
    `;
  }).join('');

  // Stats row
  els.statsRow.innerHTML = `
    <div class="stat-card"><span class="stat-value">${r.aggregated.allStyles.length}</span><span class="stat-label">Classes</span></div>
    <div class="stat-card"><span class="stat-value">${r.aggregated.pageCount}</span><span class="stat-label">Pages</span></div>
    <div class="stat-card"><span class="stat-value">${r.aggregated.totalElements}</span><span class="stat-label">Elements</span></div>
    <div class="stat-card"><span class="stat-value">${r.aggregated.allInteractions.length}</span><span class="stat-label">Interactions</span></div>
    <div class="stat-card"><span class="stat-value">${r.aggregated.unlinkedSymbols}</span><span class="stat-label">Unlinked Symbols</span></div>
  `;

  // Brief
  els.pagesAnalyzed.textContent = `${r.aggregated.pageCount} page${r.aggregated.pageCount > 1 ? 's' : ''} analyzed: ${r.pages.map(p => p.name).join(', ')}`;
  els.briefContent.innerHTML = r.brief;
  
  // Priority recommendations
  els.priorityList.innerHTML = r.recommendations.map(rec => `
    <div class="priority-item ${rec.priority}">
      <span class="priority-badge">${rec.priority}</span>
      <div class="priority-content">
        <div class="priority-title">${escapeHtml(rec.title)}</div>
        <div class="priority-desc">${escapeHtml(rec.desc)}</div>
        <div class="priority-impact">Impact: ${escapeHtml(rec.impact)}</div>
      </div>
    </div>
  `).join('') || '<p class="empty-msg">No major issues found!</p>';
  
  // Quick wins
  if (r.quickWins.length > 0) {
    els.quickWins.classList.remove('hidden');
    els.quickWinsList.innerHTML = r.quickWins.map(w => 
      `<div class="quick-win-item">${escapeHtml(w)}</div>`
    ).join('');
  } else {
    els.quickWins.classList.add('hidden');
  }
  
  // Risk assessment
  if (r.riskAssessment.length > 0) {
    els.riskSection.classList.remove('hidden');
    els.riskGrid.innerHTML = r.riskAssessment.map(risk => `
      <div class="risk-item">
        <div class="risk-class">.${escapeHtml(risk.name)}</div>
        <div class="risk-reason">${escapeHtml(risk.reason)}</div>
        <div class="risk-count">Used ${risk.usage} times across ${risk.pages} page${risk.pages > 1 ? 's' : ''}</div>
      </div>
    `).join('');
  } else {
    // No risky classes found - either framework is handling it well, or project is small
    if (r.aggregated.allStyles.length > 50) {
      els.riskSection.classList.remove('hidden');
      els.riskGrid.innerHTML = `<div class="risk-item" style="border-color: #22c55e;">
        <div class="risk-class" style="color: #22c55e;">‚úì No high-risk classes detected</div>
        <div class="risk-reason">Utility and framework classes are properly used for reusability</div>
      </div>`;
    } else {
      els.riskSection.classList.add('hidden');
    }
  }

  // Page breakdown
  if (r.aggregated.pageCount > 1) {
    els.breakdownCard.style.display = 'block';
    els.pageBreakdown.innerHTML = r.pages.map(p => `
      <div class="breakdown-item">
        <span class="breakdown-name">${escapeHtml(p.name)}</span>
        <div class="breakdown-stats">
          <span class="breakdown-stat">${p.classCount} classes</span>
          <span class="breakdown-stat">${p.elementCount} elements</span>
        </div>
      </div>
    `).join('');
  } else {
    els.breakdownCard.style.display = 'none';
  }

  // Detailed findings
  displayFindings(r.findings);

  // Export
  const exportData = {
    exportVersion: '2.0',
    exportDate: new Date().toISOString(),
    score: r.score,
    grade: r.grade,
    complexity: r.complexity.level,
    intentionality: r.intentionality,
    framework: r.framework,
    pages: r.pages,
    recommendations: r.recommendations,
    quickWins: r.quickWins
  };
  els.exportOutput.value = JSON.stringify(exportData, null, 2);
  
  // Render data explorer
  explorerExpandedNodes = new Set(['root']);
  // Auto-expand root nodes
  const rootNodes = findRootNodes(r.aggregated.allNodes, r.aggregated.nodeMap);
  rootNodes.forEach(n => explorerExpandedNodes.add('node-' + n._id));
  renderExplorer();
  
  // Register issue data for clickable details
  registerAllIssueData(r);
}

function registerAllIssueData(r) {
  issueDataMap.clear();
  
  const { metrics, findings } = r;
  
  // Naming issues
  if (metrics.naming.issues.length > 0) {
    metrics.naming.issues.forEach((issue, idx) => {
      if (issue.includes('numbered classes with identical CSS')) {
        registerIssueData(`naming-${idx}`, 
          'Numbered Classes with Identical CSS',
          'These classes share a base name and have identical CSS. They should be merged into a single class.',
          () => {
            const groups = metrics.naming.data.numberedWithSameCss || [];
            if (groups.length === 0) return '<p class="empty-msg">No details available</p>';
            return groups.map(group => `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge high">${group.count} classes should be merged</span>
                </div>
                <div class="issue-list-item-group">
                  ${group.styles.map(s => `
                    <span class="issue-list-item-class" style="${s.isCombo ? 'border: 1px solid #fbbf24;' : ''}">
                      .${escapeHtml(s.name)}${s.isCombo ? ' <small style="color:#fbbf24">(combo)</small>' : ''}
                    </span>
                  `).join('')}
                </div>
                <div class="issue-list-item-css">${escapeHtml(group.css)}${group.css.length >= 150 ? '...' : ''}</div>
                <div class="issue-list-item-detail" style="margin-top: 12px; padding: 10px; background: #1a3a1a; border-radius: 6px; border-left: 3px solid #22c55e;">
                  <strong style="color: #22c55e;">‚úì Suggestion:</strong> ${escapeHtml(group.suggestion)}
                </div>
              </div>
            `).join('');
          }
        );
      } else if (issue.includes('copied classes')) {
        registerIssueData(`naming-${idx}`,
          'Copied Classes (Critical)',
          'Classes ending with "-copy" indicate duplicated elements. These create maintenance nightmares and should be renamed or consolidated.',
          () => {
            const critical = metrics.naming.data.autoGenerated.critical || [];
            if (critical.length === 0) return '<p class="empty-msg">No details available</p>';
            return critical.map(item => `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-class">.${escapeHtml(item.name)}</span>
                  <span class="issue-list-item-badge critical">Critical</span>
                </div>
                <div class="issue-list-item-detail">${escapeHtml(item.desc)}</div>
              </div>
            `).join('');
          }
        );
      } else if (issue.includes('numbered auto-classes')) {
        registerIssueData(`naming-${idx}`,
          'Numbered Auto-Generated Classes',
          'Classes like "div-block-2" or "section-3" indicate the developer didn\'t name elements intentionally. These should be given semantic names.',
          () => {
            const high = metrics.naming.data.autoGenerated.high || [];
            if (high.length === 0) return '<p class="empty-msg">No details available</p>';
            return high.map(item => `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-class">.${escapeHtml(item.name)}</span>
                  <span class="issue-list-item-badge high">High</span>
                </div>
                <div class="issue-list-item-detail">${escapeHtml(item.desc)}</div>
              </div>
            `).join('');
          }
        );
      } else if (issue.includes('duplicate styles')) {
        registerIssueData(`naming-${idx}`,
          'Duplicate Styles',
          'Different class names with identical CSS. These should be merged to reduce complexity.',
          () => {
            const dupes = metrics.naming.data.duplicateCss || [];
            if (dupes.length === 0) return '<p class="empty-msg">No details available</p>';
            return dupes.slice(0, 10).map(dup => `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge medium">${dup.names.length} classes</span>
                </div>
                <div class="issue-list-item-group">
                  ${dup.names.map(name => `<span class="issue-list-item-class">.${escapeHtml(name)}</span>`).join('')}
                </div>
                <div class="issue-list-item-css">${escapeHtml(dup.css)}...</div>
              </div>
            `).join('');
          }
        );
      } else {
        // Generic fallback
        registerIssueData(`naming-${idx}`, 'Naming Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
  
  // Style consistency issues
  if (metrics.styleConsistency.issues.length > 0) {
    metrics.styleConsistency.issues.forEach((issue, idx) => {
      if (issue.includes('near-duplicate color')) {
        registerIssueData(`styleConsistency-${idx}`,
          'Near-Duplicate Colors',
          'Colors that are almost identical but not the same. This usually indicates a missing design system or accidental inconsistency.',
          () => {
            const pairs = metrics.styleConsistency.data.nearDuplicateColors || [];
            if (pairs.length === 0) return '<p class="empty-msg">No details available</p>';
            return pairs.map(pair => `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <div style="display: flex; gap: 8px; align-items: center;">
                    <div style="width: 32px; height: 32px; border-radius: 6px; background: ${pair.color1.value}; border: 1px solid #333;"></div>
                    <span style="color: #666;">vs</span>
                    <div style="width: 32px; height: 32px; border-radius: 6px; background: ${pair.color2.value}; border: 1px solid #333;"></div>
                  </div>
                  <span class="issue-list-item-badge medium">${pair.percentage}% similar</span>
                </div>
                <div class="issue-list-item-detail">
                  <code>${pair.color1.value}</code> vs <code>${pair.color2.value}</code><br>
                  Used in: ${[...pair.color1.classes, ...pair.color2.classes].slice(0, 4).map(c => '.' + c).join(', ')}
                </div>
              </div>
            `).join('');
          }
        );
      } else if (issue.includes('spacing off-scale') || issue.includes('Inconsistent')) {
        registerIssueData(`styleConsistency-${idx}`,
          'Inconsistent Spacing',
          'Spacing values that don\'t follow a consistent scale. Professional projects use 4px or 8px increments.',
          () => {
            const nearDupes = metrics.styleConsistency.data.spacingAnalysis.nearDuplicates || [];
            const offScale = metrics.styleConsistency.data.spacingAnalysis.offScaleWithClasses || [];
            let html = '';
            if (nearDupes.length > 0) {
              html += nearDupes.map(s => `
                <div class="issue-list-item">
                  <div class="issue-list-item-header">
                    <span class="issue-list-item-badge medium">Near-duplicate ${s.sharedCategory || 'spacing'}: ${s.v1}px vs ${s.v2}px</span>
                  </div>
                  <div class="issue-list-item-detail">
                    <strong>${s.v1}px used in:</strong> ${s.classes1.slice(0, 5).map(c => '.' + c).join(', ')}${s.classes1.length > 5 ? ` +${s.classes1.length - 5} more` : ''}<br>
                    <strong>${s.v2}px used in:</strong> ${s.classes2.slice(0, 5).map(c => '.' + c).join(', ')}${s.classes2.length > 5 ? ` +${s.classes2.length - 5} more` : ''}
                  </div>
                  <div class="issue-list-item-detail" style="margin-top: 10px; padding: 10px; background: #1a2a3a; border-radius: 6px; border-left: 3px solid #3b82f6;">
                    <strong style="color: #3b82f6;">üí° Tip:</strong> Consider using CSS variables for consistent ${s.sharedCategory || 'spacing'} values
                  </div>
                </div>
              `).join('');
            }
            if (offScale.length > 0) {
              html += `<div class="issue-list-item">
                <div class="issue-list-item-header"><span class="issue-list-item-badge low">Off-scale values</span></div>
                <div class="issue-list-item-detail">
                  ${offScale.slice(0, 10).map(item => `
                    <div style="margin: 8px 0; padding: 8px; background: #1a1a1a; border-radius: 6px;">
                      <strong>${item.value}px</strong> ‚Äî ${item.classes.slice(0, 4).map(c => '.' + c).join(', ')}${item.classes.length > 4 ? ` +${item.classes.length - 4} more` : ''}
                    </div>
                  `).join('')}
                </div>
              </div>`;
            }
            return html || '<p class="empty-msg">No details available</p>';
          }
        );
      } else if (issue.includes('CSS variables')) {
        registerIssueData(`styleConsistency-${idx}`,
          'No CSS Variables',
          'The project doesn\'t use CSS variables for colors. Variables make global changes much easier.',
          () => `<div class="issue-list-item">
            <div class="issue-list-item-detail">
              Create CSS variables for your main brand colors. This allows you to update colors site-wide from one place.<br><br>
              <strong>Example:</strong><br>
              <code>--color-primary: #4a9eff;</code><br>
              <code>--color-text: #e0e0e0;</code>
            </div>
          </div>`
        );
      } else {
        registerIssueData(`styleConsistency-${idx}`, 'Style Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
  
  // Typography issues
  if (metrics.typography.issues.length > 0) {
    metrics.typography.issues.forEach((issue, idx) => {
      if (issue.includes('font sizes') || issue.includes('font families')) {
        registerIssueData(`typography-${idx}`,
          'Typography Inconsistency',
          'Too many font sizes or families indicate a lack of type system. Professional designs use 6-8 sizes maximum.',
          () => {
            const typo = metrics.typography.data.typography;
            let html = '<div class="issue-list-item">';
            if (typo.families.size > 0) {
              html += `<div class="issue-list-item-header"><span class="issue-list-item-badge medium">${typo.families.size} Font Families</span></div>`;
              html += `<div class="issue-list-item-detail">${Array.from(typo.families).join(', ')}</div>`;
            }
            if (typo.sizes.length > 0) {
              const uniqueSizes = [...new Set(typo.sizes.map(s => s.value))].sort((a, b) => a - b);
              html += `<div style="margin-top: 12px;"><strong>${uniqueSizes.length} unique font sizes:</strong></div>`;
              html += `<div class="issue-list-item-detail">${uniqueSizes.map(s => s + 'px').join(', ')}</div>`;
            }
            html += '</div>';
            return html;
          }
        );
      } else if (issue.includes('type scale')) {
        registerIssueData(`typography-${idx}`,
          'No Type Scale',
          'Font sizes don\'t follow a consistent ratio. A type scale (like 1.25x) creates visual harmony.',
          () => `<div class="issue-list-item">
            <div class="issue-list-item-detail">
              Consider using a type scale with consistent ratios:<br><br>
              <strong>1.25 scale example:</strong> 12px ‚Üí 15px ‚Üí 19px ‚Üí 24px ‚Üí 30px<br>
              <strong>1.333 scale example:</strong> 12px ‚Üí 16px ‚Üí 21px ‚Üí 28px ‚Üí 37px
            </div>
          </div>`
        );
      } else {
        registerIssueData(`typography-${idx}`, 'Typography Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
  
  // Architecture issues
  if (metrics.architecture.issues.length > 0) {
    metrics.architecture.issues.forEach((issue, idx) => {
      if (issue.includes('nesting depth')) {
        registerIssueData(`architecture-${idx}`,
          'Deep Nesting',
          'Elements are nested too deeply. This makes the project hard to navigate and maintain. Aim for 6-8 levels maximum.',
          () => {
            const nesting = metrics.architecture.data.nestingAnalysis;
            let html = `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge high">Max depth: ${nesting.maxDepth} levels</span>
              </div>
              <div class="issue-list-item-detail">
                Recommended maximum: 6-8 levels.<br>
                Deep nesting often indicates workarounds or poor structure planning.
              </div>
            </div>`;
            
            if (nesting.deepNodes && nesting.deepNodes.length > 0) {
              html += `<div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge medium">Deepest elements (${nesting.maxDepth} levels deep)</span>
                </div>
                <div class="issue-list-item-detail">
                  <p style="margin-bottom: 12px; color: #888;">To find these in Webflow, follow the path from the root:</p>
                  ${nesting.deepNodes.slice(0, 5).map(node => `
                    <div style="margin: 12px 0; padding: 12px; background: #1a1a1a; border-radius: 8px; border-left: 3px solid #f97316;">
                      <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                        <strong style="color: #fff;">Target element:</strong>
                        <span style="color: #4a9eff;">&lt;${node.tag || 'div'}&gt;</span>
                        <span style="color: #a78bfa;">${node.type}</span>
                        ${node.classes.length > 0 
                          ? `<span style="color: #00d4aa;">.${node.classes.join(' .')}</span>` 
                          : '<span style="color: #666; font-style: italic;">(no class applied)</span>'}
                      </div>
                      ${node.path && node.path.length > 0 ? `
                        <div style="font-size: 12px; color: #888; margin-top: 8px;">
                          <strong style="color: #aaa;">Full path from root:</strong>
                          <div style="margin-top: 6px; padding: 8px; background: #0a0a0a; border-radius: 6px; font-family: 'SF Mono', Monaco, monospace; overflow-x: auto;">
                            ${node.path.map((p, i) => {
                              const label = p.classes.length > 0 ? '.' + p.classes[0] : `[${p.type}]`;
                              const color = p.classes.length > 0 ? '#00d4aa' : '#666';
                              return `<span style="color: ${color}">${escapeHtml(label)}</span>`;
                            }).join('<span style="color: #444; margin: 0 4px;">‚Üí</span>')}
                          </div>
                        </div>
                        <div style="font-size: 11px; color: #666; margin-top: 8px;">
                          üí° In Webflow Navigator, look for: ${node.path.filter(p => p.classes.length > 0).slice(0, 3).map(p => '.' + p.classes[0]).join(' inside ') || 'unnamed elements (add classes to find easier)'}
                        </div>
                      ` : ''}
                    </div>
                  `).join('')}
                </div>
              </div>`;
            }
            
            return html;
          }
        );
      } else if (issue.includes('empty wrapper')) {
        registerIssueData(`architecture-${idx}`,
          'Empty Wrapper Divs',
          'Divs with no classes and only one child add unnecessary complexity. They can usually be removed.',
          () => {
            const count = metrics.architecture.data.nestingAnalysis.emptyWrappers;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge medium">${count} empty wrappers</span>
              </div>
              <div class="issue-list-item-detail">
                These are divs that have no class applied and contain only a single child element.<br>
                They usually serve no purpose and can be removed to flatten the structure.
              </div>
            </div>`;
          }
        );
      } else if (issue.includes('unlinked symbols')) {
        registerIssueData(`architecture-${idx}`,
          'Unlinked Symbols',
          'Components that were created then "unlinked" become tech debt. Changes don\'t propagate, defeating the purpose of components.',
          () => {
            const count = r.aggregated.unlinkedSymbols;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge high">${count} unlinked symbols</span>
              </div>
              <div class="issue-list-item-detail">
                When you unlink a symbol, it becomes a regular element. Any future updates to the original symbol won't apply.<br><br>
                Consider re-linking these or creating new symbols if the original was deleted.
              </div>
            </div>`;
          }
        );
      } else if (issue.includes('nesting') && issue.includes('levels')) {
        registerIssueData(`architecture-${idx}`,
          'Deep Nesting Detected',
          'Elements are nested too deeply, making the structure hard to maintain and potentially impacting performance.',
          () => {
            const nesting = metrics.architecture.data.nestingAnalysis;
            const deepNodes = nesting.deepNodes || [];
            if (deepNodes.length === 0) {
              return `<div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge high">Max depth: ${nesting.maxDepth} levels</span>
                </div>
                <div class="issue-list-item-detail">
                  The element tree is nested ${nesting.maxDepth} levels deep. Consider flattening the structure.
                </div>
              </div>`;
            }
            return deepNodes.slice(0, 5).map(node => {
              const pathStr = node.path.map(p => {
                const cls = p.classes.length > 0 ? `.${p.classes[0]}` : `[${p.type}]`;
                return `<span style="color: #94a3b8;">${escapeHtml(cls)}</span>`;
              }).join(' <span style="color: #475569;">‚Üí</span> ');
              return `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge high">${node.depth} levels deep</span>
                </div>
                <div class="issue-list-item-detail" style="font-family: monospace; font-size: 12px; overflow-x: auto; white-space: nowrap;">
                  ${pathStr}
                </div>
              </div>`;
            }).join('');
          }
        );
      } else {
        registerIssueData(`architecture-${idx}`, 'Architecture Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
  
  // Component issues
  if (metrics.components && metrics.components.issues.length > 0) {
    metrics.components.issues.forEach((issue, idx) => {
      if (issue.includes('Navigation is not a component')) {
        registerIssueData(`components-${idx}`,
          'Navigation Not a Component',
          'Your navigation appears on multiple pages but isn\'t built as a reusable component. This makes updates risky and time-consuming.',
          () => {
            const nav = metrics.components.data.navAnalysis;
            const historical = metrics.components.data.historicalNote;
            let html = `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge high">Critical Issue</span>
              </div>
              <div class="issue-list-item-detail">
                Navigation found on ${nav.instances?.length || 'multiple'} pages but not as a component.<br><br>
                <strong>Impact:</strong> Every nav update must be made ${nav.instances?.length || 'multiple'} times manually.<br>
                <strong>Risk:</strong> Inconsistencies, missed updates, increased maintenance time.
              </div>
            </div>`;
            
            if (nav.instances && nav.instances.length > 0) {
              html += `<div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge medium">Found on pages:</span>
                </div>
                <div class="issue-list-item-group" style="margin-top: 10px;">
                  ${[...new Set(nav.instances.map(i => i.page))].slice(0, 10).map(p => 
                    `<span class="issue-list-item-class">${escapeHtml(p)}</span>`
                  ).join('')}
                </div>
              </div>`;
            }
            
            html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a3a1a; border-radius: 6px; border-left: 3px solid #22c55e;">
              <strong style="color: #22c55e;">‚úì Solution:</strong> Convert your navigation to a Component (symbol). 
              Select the nav element ‚Üí Right-click ‚Üí "Create Component". Then replace the nav on all pages with this component.
            </div>`;
            
            if (historical) {
              html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a2a3a; border-radius: 6px; border-left: 3px solid #3b82f6;">
                <strong style="color: #3b82f6;">üìÖ Historical Note:</strong> ${escapeHtml(historical)}
              </div>`;
            }
            
            return html;
          }
        );
      } else if (issue.includes('Footer is not a component')) {
        registerIssueData(`components-${idx}`,
          'Footer Not a Component',
          'Your footer appears on multiple pages but isn\'t built as a reusable component.',
          () => {
            const footer = metrics.components.data.footerAnalysis;
            const historical = metrics.components.data.historicalNote;
            let html = `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge high">Critical Issue</span>
              </div>
              <div class="issue-list-item-detail">
                Footer found on ${footer.instances?.length || 'multiple'} pages but not as a component.<br><br>
                <strong>Impact:</strong> Footer updates (links, copyright year, etc.) must be done manually on each page.<br>
                <strong>Risk:</strong> Outdated information, inconsistent footer content.
              </div>
            </div>`;
            
            html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a3a1a; border-radius: 6px; border-left: 3px solid #22c55e;">
              <strong style="color: #22c55e;">‚úì Solution:</strong> Convert your footer to a Component.
              This ensures updates propagate to all pages automatically.
            </div>`;
            
            if (historical) {
              html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a2a3a; border-radius: 6px; border-left: 3px solid #3b82f6;">
                <strong style="color: #3b82f6;">üìÖ Historical Note:</strong> ${escapeHtml(historical)}
              </div>`;
            }
            
            return html;
          }
        );
      } else if (issue.includes('repeated patterns')) {
        registerIssueData(`components-${idx}`,
          'Repeated Patterns Should Be Components',
          'Similar structures are being copied across pages instead of using reusable components.',
          () => {
            const patterns = metrics.components.data.patternAnalysis.shouldBeComponents || [];
            const historical = metrics.components.data.historicalNote;
            
            if (patterns.length === 0) {
              return '<p class="empty-msg">No specific patterns recorded</p>';
            }
            
            let html = patterns.slice(0, 6).map(pattern => `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge medium">Found ${pattern.totalCount}√ó on ${pattern.pageCount} pages</span>
                </div>
                <div class="issue-list-item-detail">
                  <strong>Pattern:</strong> ${escapeHtml(pattern.classPattern || 'Unnamed structure')}<br>
                  <strong>Type:</strong> ${escapeHtml(pattern.instances[0]?.type || 'Block')} with ${pattern.childCount} children<br>
                  <strong>Pages:</strong> ${[...new Set(pattern.instances.map(i => i.page))].slice(0, 5).join(', ')}
                </div>
                <div class="issue-list-item-detail" style="margin-top: 10px; padding: 10px; background: #1a2a1a; border-radius: 6px;">
                  <strong style="color: #86efac;">üí° Likely candidate:</strong> ${pattern.suggestion}
                </div>
              </div>
            `).join('');
            
            html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a3a1a; border-radius: 6px; border-left: 3px solid #22c55e;">
              <strong style="color: #22c55e;">‚úì Solution:</strong> Convert repeated sections to Components.<br>
              Use Component Variables (properties) to customize colors, text, or images while keeping the structure consistent.
            </div>`;
            
            if (historical) {
              html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a2a3a; border-radius: 6px; border-left: 3px solid #3b82f6;">
                <strong style="color: #3b82f6;">üìÖ Historical Note:</strong> ${escapeHtml(historical)}
              </div>`;
            }
            
            return html;
          }
        );
      } else if (issue.includes('No components detected') || issue.includes('Low component usage')) {
        registerIssueData(`components-${idx}`,
          'Low Component Usage',
          'This project has few or no reusable components, making maintenance more difficult.',
          () => {
            const comp = metrics.components.data.componentAnalysis;
            const historical = metrics.components.data.historicalNote;
            
            let html = `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge medium">${comp.totalComponents} components total</span>
              </div>
              <div class="issue-list-item-detail">
                Components (symbols) allow you to update once and propagate changes everywhere.<br><br>
                <strong>Recommendation:</strong> Start with navigation, footer, and frequently-used sections.
              </div>
            </div>`;
            
            html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a3a1a; border-radius: 6px; border-left: 3px solid #22c55e;">
              <strong style="color: #22c55e;">‚úì Quick wins:</strong><br>
              ‚Ä¢ Navigation ‚Üí Component<br>
              ‚Ä¢ Footer ‚Üí Component<br>
              ‚Ä¢ Card layouts ‚Üí Component with variables<br>
              ‚Ä¢ CTA sections ‚Üí Component with variables
            </div>`;
            
            if (historical) {
              html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a2a3a; border-radius: 6px; border-left: 3px solid #3b82f6;">
                <strong style="color: #3b82f6;">üìÖ Historical Note:</strong> ${escapeHtml(historical)}
              </div>`;
            }
            
            return html;
          }
        );
      } else {
        registerIssueData(`components-${idx}`, 'Component Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
  
  // Maintainability issues
  if (metrics.maintainability.issues.length > 0) {
    metrics.maintainability.issues.forEach((issue, idx) => {
      if (issue.includes('button') && issue.includes('variant')) {
        registerIssueData(`maintainability-${idx}`,
          'Missing Button Variants',
          'A button class exists but has no combo classes for variants. Buttons typically need primary, secondary, and size variations.',
          () => `<div class="issue-list-item">
            <div class="issue-list-item-detail">
              Create combo classes for button variants:<br><br>
              <code>.button.is-primary</code><br>
              <code>.button.is-secondary</code><br>
              <code>.button.is-large</code><br>
              <code>.button.is-small</code>
            </div>
          </div>`
        );
      } else if (issue.includes('empty classes')) {
        registerIssueData(`maintainability-${idx}`,
          'Empty Classes',
          'Classes that exist but have no CSS applied. Unless they\'re JavaScript hooks (js-*), they add clutter.',
          () => {
            const count = metrics.maintainability.data.emptyClasses;
            const classList = metrics.maintainability.data.emptyClassList || [];
            // Deduplicate class names
            const uniqueClasses = [...new Set(classList)];
            
            // Identify likely JS hook patterns
            const likelyJsHooks = uniqueClasses.filter(name => 
              name.includes('hide') || 
              name.includes('show') || 
              name.includes('active') || 
              name.includes('toggle') ||
              name.includes('state') ||
              name.includes('is-') ||
              name.includes('has-')
            );
            const otherEmpty = uniqueClasses.filter(name => !likelyJsHooks.includes(name));
            
            let html = '';
            
            if (likelyJsHooks.length > 0) {
              html += `<div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge" style="background: #1a3a1a; color: #22c55e;">${likelyJsHooks.length} likely JS hooks</span>
                </div>
                <div class="issue-list-item-detail" style="color: #86efac;">
                  These classes may be used by JavaScript for state management. Verify before removing.
                </div>
                <div class="issue-list-item-group" style="margin-top: 10px;">
                  ${likelyJsHooks.slice(0, 15).map(name => `<span class="issue-list-item-class" style="border-color: #22c55e;">.${escapeHtml(name)}</span>`).join('')}
                  ${likelyJsHooks.length > 15 ? `<span class="issue-list-item-class" style="background: #333;">+${likelyJsHooks.length - 15} more</span>` : ''}
                </div>
              </div>`;
            }
            
            if (otherEmpty.length > 0) {
              html += `<div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-badge medium">${otherEmpty.length} empty classes</span>
                </div>
                <div class="issue-list-item-detail">
                  These classes have no styles. Check if they're used in custom code before removing.
                </div>
                <div class="issue-list-item-group" style="margin-top: 10px;">
                  ${otherEmpty.slice(0, 20).map(name => `<span class="issue-list-item-class">.${escapeHtml(name)}</span>`).join('')}
                  ${otherEmpty.length > 20 ? `<span class="issue-list-item-class" style="background: #333;">+${otherEmpty.length - 20} more</span>` : ''}
                </div>
              </div>`;
            }
            
            html += `<div class="issue-list-item" style="margin-top: 12px; padding: 12px; background: #1a2a3a; border-radius: 6px; border-left: 3px solid #3b82f6;">
              <strong style="color: #3b82f6;">üí° Tip:</strong> Search your custom code for these class names before deleting. 
              Scripts often use empty classes for targeting elements (e.g., <code>.querySelectorAll('.hide_now')</code>).
            </div>`;
            
            return html;
          }
        );
      } else if (issue.includes('single page only')) {
        registerIssueData(`maintainability-${idx}`,
          'Low Class Reuse',
          'Many classes are only used on one page. This suggests duplication instead of a reusable system.',
          () => {
            const ratio = metrics.maintainability.data.reuseAnalysis.orphanRatio;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge medium">${Math.round(ratio * 100)}% single-page classes</span>
              </div>
              <div class="issue-list-item-detail">
                In a well-architected project, most classes should be reusable across pages.<br>
                High orphan ratios indicate page-specific styling instead of a system.
              </div>
            </div>`;
          }
        );
      } else {
        registerIssueData(`maintainability-${idx}`, 'Maintainability Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
  
  // Technical issues
  if (metrics.technical.issues.length > 0) {
    metrics.technical.issues.forEach((issue, idx) => {
      if (issue.includes('absolute positioning')) {
        registerIssueData(`technical-${idx}`,
          'Excessive Absolute Positioning',
          'Too many elements use position:absolute. This often indicates layout workarounds rather than proper flexbox/grid usage.',
          () => {
            const count = metrics.technical.data.positionAnalysis.absoluteCount;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge high">${count} absolute elements</span>
              </div>
              <div class="issue-list-item-detail">
                Absolute positioning should be used sparingly for overlays, badges, and decorative elements.<br>
                High counts suggest the developer is fighting the layout instead of using flexbox/grid properly.
              </div>
            </div>`;
          }
        );
      } else if (issue.includes('Z-index chaos')) {
        registerIssueData(`technical-${idx}`,
          'Z-Index Chaos',
          'Z-index values are unorganized with extreme values. This leads to stacking issues and "z-index wars".',
          () => {
            const zValues = metrics.technical.data.positionAnalysis.zIndexValues;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge high">Z-index values</span>
              </div>
              <div class="issue-list-item-detail">
                Current values: ${zValues.join(', ')}<br><br>
                <strong>Recommended system:</strong><br>
                1-10: Base elements<br>
                10-20: Dropdowns, tooltips<br>
                20-30: Modals<br>
                30-40: Notifications<br>
                Values like 999 or 9999 indicate problems.
              </div>
            </div>`;
          }
        );
      } else if (issue.includes('overflow:hidden')) {
        registerIssueData(`technical-${idx}`,
          'Excessive Overflow Hidden',
          'Many elements have overflow:hidden. This is often used to hide broken layouts or unwanted scrollbars.',
          () => {
            const count = metrics.technical.data.positionAnalysis.overflowHiddenCount;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge medium">${count} overflow:hidden</span>
              </div>
              <div class="issue-list-item-detail">
                Overflow hidden should be intentional, not a band-aid. Common misuses:<br>
                ‚Ä¢ Hiding horizontal scroll caused by elements too wide<br>
                ‚Ä¢ Hiding content that "shouldn't" be visible<br>
                ‚Ä¢ Working around animation glitches
              </div>
            </div>`;
          }
        );
      } else if (issue.includes('interaction')) {
        registerIssueData(`technical-${idx}`,
          'Interaction Complexity',
          'Many interactions exist in this project. Each interaction adds maintenance overhead.',
          () => {
            const count = metrics.technical.data.interactionCount;
            return `<div class="issue-list-item">
              <div class="issue-list-item-header">
                <span class="issue-list-item-badge medium">${count} interactions</span>
              </div>
              <div class="issue-list-item-detail">
                Interactions add visual polish but require maintenance:<br>
                ‚Ä¢ Each interaction must be tested across browsers<br>
                ‚Ä¢ Changes to elements can break animations<br>
                ‚Ä¢ Complex timelines are hard to modify<br><br>
                Consider reusing interactions where possible.
              </div>
            </div>`;
          }
        );
      } else if (issue.includes('breakpoint')) {
        registerIssueData(`technical-${idx}`,
          'Breakpoint Inconsistencies',
          'Responsive styles don\'t follow predictable patterns. Mobile spacing shouldn\'t exceed desktop spacing.',
          () => {
            const issues = metrics.technical.data.breakpointAnalysis.breakpointIssues || [];
            if (issues.length === 0) return '<p class="empty-msg">No specific issues recorded</p>';
            return issues.slice(0, 8).map(issue => {
              const bpName = BREAKPOINT_NAMES[issue.breakpoint] || issue.breakpoint;
              return `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-class">.${escapeHtml(issue.class)}</span>
                  <span class="issue-list-item-badge medium">${escapeHtml(bpName)}</span>
                </div>
                <div class="issue-list-item-detail">${escapeHtml(issue.issue)}</div>
              </div>
            `}).join('');
          }
        );
      } else if (issue.includes('mobile spacing')) {
        registerIssueData(`technical-${idx}`,
          'Mobile Spacing Issues',
          'These classes have spacing that increases on smaller breakpoints, which is usually unintentional.',
          () => {
            const bpIssues = metrics.technical.data.breakpointAnalysis.breakpointIssues || [];
            const mobileIssues = bpIssues.filter(i => 
              i.breakpoint.includes('small') || i.breakpoint.includes('tiny') || i.breakpoint.includes('mobile')
            );
            if (mobileIssues.length === 0) {
              return `<p class="empty-msg">No specific mobile issues recorded</p>`;
            }
            return mobileIssues.slice(0, 8).map(issue => {
              const bpName = BREAKPOINT_NAMES[issue.breakpoint] || issue.breakpoint;
              return `
              <div class="issue-list-item">
                <div class="issue-list-item-header">
                  <span class="issue-list-item-class">.${escapeHtml(issue.class)}</span>
                  <span class="issue-list-item-badge medium">${escapeHtml(bpName)}</span>
                </div>
                <div class="issue-list-item-detail">${escapeHtml(issue.issue)}</div>
              </div>
            `}).join('');
          }
        );
      } else {
        registerIssueData(`technical-${idx}`, 'Technical Issue', issue, () => `<p>${escapeHtml(issue)}</p>`);
      }
    });
  }
}

function displayFindings(findings) {
  // Duplicate styles
  if (findings.duplicateStyles.length > 0) {
    els.duplicateStylesSection.classList.remove('hidden');
    els.duplicateStylesList.innerHTML = findings.duplicateStyles.map(dup => `
      <div class="finding-item">
        <div class="finding-title">Identical CSS in ${dup.names.length} classes</div>
        <div class="finding-classes">${dup.names.map(n => `<span class="finding-class">.${escapeHtml(n)}</span>`).join('')}</div>
        <div class="finding-detail">${escapeHtml(dup.css)}...</div>
      </div>
    `).join('');
  } else {
    els.duplicateStylesSection.classList.add('hidden');
  }
  
  // Near-duplicate colors
  if (findings.nearDuplicateColors.length > 0) {
    els.nearDuplicateColorsSection.classList.remove('hidden');
    els.nearDuplicateColorsList.innerHTML = findings.nearDuplicateColors.map(pair => `
      <div class="color-pair">
        <div class="color-pair-swatches">
          <div class="color-pair-swatch" style="background:${pair.color1.value}"></div>
          <div class="color-pair-swatch" style="background:${pair.color2.value}"></div>
        </div>
        <div class="color-pair-info">${pair.color1.value} vs ${pair.color2.value}</div>
        <div class="color-pair-diff">${pair.percentage}% similar</div>
      </div>
    `).join('');
  } else {
    els.nearDuplicateColorsSection.classList.add('hidden');
  }
  
  // Spacing issues
  if (findings.spacingIssues.length > 0) {
    els.inconsistentSpacingSection.classList.remove('hidden');
    els.inconsistentSpacingList.innerHTML = findings.spacingIssues.map(s => `
      <div class="finding-item">
        <div class="finding-title">${s.v1}px vs ${s.v2}px (${s.diff}px difference)</div>
        <div class="finding-detail">Consider standardizing to one value</div>
      </div>
    `).join('');
  } else {
    els.inconsistentSpacingSection.classList.add('hidden');
  }
  
  // Auto-generated classes
  const criticalAuto = findings.autoGenerated.filter(a => a.severity === 'critical' || a.severity === 'high');
  if (criticalAuto.length > 0) {
    els.autoGeneratedSection.classList.remove('hidden');
    els.autoGeneratedList.innerHTML = criticalAuto.slice(0, 10).map(a => `
      <div class="finding-item">
        <div class="finding-title">.${escapeHtml(a.name)}</div>
        <div class="finding-detail">${escapeHtml(a.desc)} - ${a.severity} severity</div>
      </div>
    `).join('');
  } else {
    els.autoGeneratedSection.classList.add('hidden');
  }
  
  // Nesting issues
  if (findings.nestingIssues.maxDepth > 6) {
    els.nestingSection.classList.remove('hidden');
    els.nestingList.innerHTML = `
      <div class="finding-item">
        <div class="finding-title">Maximum nesting: ${findings.nestingIssues.maxDepth} levels</div>
        <div class="finding-detail">Recommended maximum: 6-8 levels for maintainability</div>
      </div>
      ${findings.nestingIssues.emptyWrappers > 0 ? `
        <div class="finding-item">
          <div class="finding-title">${findings.nestingIssues.emptyWrappers} empty wrapper divs</div>
          <div class="finding-detail">Divs with no classes and single children add unnecessary complexity</div>
        </div>
      ` : ''}
    `;
  } else {
    els.nestingSection.classList.add('hidden');
  }
  
  // Positioning issues
  const posIssues = findings.positioningIssues;
  if (posIssues.absoluteCount > 10 || posIssues.zIndexChaos) {
    els.positioningSection.classList.remove('hidden');
    let html = '';
    if (posIssues.absoluteCount > 10) {
      html += `<div class="finding-item"><div class="finding-title">${posIssues.absoluteCount} absolute positioned elements</div><div class="finding-detail">High count suggests layout workarounds</div></div>`;
    }
    if (posIssues.zIndexChaos) {
      html += `<div class="finding-item"><div class="finding-title">Z-index values: ${posIssues.zIndexValues.join(', ')}</div><div class="finding-detail">Values over 100 or too many unique values indicate problems</div></div>`;
    }
    els.positioningList.innerHTML = html;
  } else {
    els.positioningSection.classList.add('hidden');
  }
  
  // Breakpoint issues
  if (findings.breakpointIssues && findings.breakpointIssues.length > 0) {
    els.breakpointSection.classList.remove('hidden');
    els.breakpointList.innerHTML = findings.breakpointIssues.slice(0, 8).map(issue => `
      <div class="finding-item">
        <div class="finding-title">.${escapeHtml(issue.class)}</div>
        <div class="finding-detail">${escapeHtml(issue.issue)}</div>
        ${issue.base && issue.variant ? `<div class="finding-detail">Desktop: ${issue.base}px ‚Üí ${issue.breakpoint}: ${issue.variant}px</div>` : ''}
      </div>
    `).join('');
  } else {
    els.breakpointSection.classList.add('hidden');
  }
  
  // Global combo warnings
  if (findings.globalComboWarnings && findings.globalComboWarnings.length > 0) {
    els.globalComboSection.classList.remove('hidden');
    els.globalComboList.innerHTML = findings.globalComboWarnings.map(warn => `
      <div class="finding-item">
        <div class="finding-title">.${escapeHtml(warn.base)} has ${warn.comboCount} combo variations</div>
        <div class="finding-detail">Consider creating a component instead of styling via combos</div>
        <div class="finding-classes">${warn.combos.slice(0, 5).map(c => `<span class="finding-class">.${escapeHtml(c)}</span>`).join('')}${warn.combos.length > 5 ? `<span class="finding-class">+${warn.combos.length - 5} more</span>` : ''}</div>
      </div>
    `).join('');
  } else {
    els.globalComboSection.classList.add('hidden');
  }
}

// ========== DATA EXPLORER ==========

function switchExplorerTab(tab) {
  explorerActiveTab = tab;
  document.querySelectorAll('.explorer-tab').forEach(t => {
    t.classList.toggle('active', t.dataset.tab === tab);
  });
  els.explorerTreeContent?.classList.toggle('hidden', tab !== 'tree');
  els.explorerStylesContent?.classList.toggle('hidden', tab !== 'styles');
  els.explorerRawContent?.classList.toggle('hidden', tab !== 'raw');
}

function expandAllExplorer() {
  if (!analysisResult) return;
  const { allNodes, allStyles } = analysisResult.aggregated;
  allNodes.forEach(n => explorerExpandedNodes.add('node-' + n._id));
  allStyles.forEach(s => explorerExpandedNodes.add('style-' + s._id));
  renderExplorer();
}

function collapseAllExplorer() {
  explorerExpandedNodes = new Set(['root']);
  renderExplorer();
}

function renderExplorer() {
  if (!analysisResult) return;
  
  const { allNodes, allStyles } = analysisResult.aggregated;
  
  // Build node map
  const nodeMap = {};
  allNodes.forEach(n => nodeMap[n._id] = n);
  
  // Build style map for name lookups
  const styleMap = {};
  allStyles.forEach(s => styleMap[s._id] = s);
  
  // Render element types
  renderExplorerTypes(allNodes);
  
  // Render tree
  renderExplorerTree(allNodes, nodeMap, styleMap);
  
  // Render styles
  renderExplorerStyles(allStyles);
  
  // Render raw JSON
  renderExplorerRaw();
  
  // Update styles count
  if (els.explorerStylesCount) {
    els.explorerStylesCount.textContent = `(${allStyles.length})`;
  }
}

function renderExplorerTypes(nodes) {
  const types = {};
  nodes.forEach(n => {
    const type = n.type || 'undefined';
    types[type] = (types[type] || 0) + 1;
  });
  
  if (els.explorerTypeTags) {
    els.explorerTypeTags.innerHTML = Object.entries(types)
      .sort((a, b) => b[1] - a[1])
      .map(([type, count]) => `
        <span class="type-tag">
          <span class="name">${escapeHtml(type)}</span>
          <span class="count">√ó${count}</span>
        </span>
      `).join('');
  }
}

function findRootNodes(nodes, nodeMap) {
  const childIds = new Set();
  nodes.forEach(n => {
    (n.children || []).forEach(id => childIds.add(id));
  });
  return nodes.filter(n => !childIds.has(n._id));
}

function getStyleName(styleId, styleMap) {
  const style = styleMap[styleId];
  return style?.name || (typeof styleId === 'string' ? styleId.substring(0, 8) : 'unknown');
}

function getNodeDisplayName(node) {
  return node.data?.displayName || node.data?.tag || '';
}

function renderExplorerTree(nodes, nodeMap, styleMap) {
  const rootNodes = findRootNodes(nodes, nodeMap);
  
  function renderNode(node, depth = 0) {
    const id = 'node-' + node._id;
    const isExpanded = explorerExpandedNodes.has(id);
    const hasChildren = node.children?.length > 0;
    const displayName = getNodeDisplayName(node);
    const classNames = (node.classes || []).map(c => getStyleName(c, styleMap));
    
    const matchesSearch = explorerSearchTerm && (
      (node.type || '').toLowerCase().includes(explorerSearchTerm) ||
      (node.tag || '').toLowerCase().includes(explorerSearchTerm) ||
      (displayName || '').toLowerCase().includes(explorerSearchTerm) ||
      classNames.some(c => c.toLowerCase().includes(explorerSearchTerm))
    );
    
    let html = `
      <div class="tree-node ${matchesSearch ? 'tree-highlight' : ''}">
        <div class="tree-node-header" data-node-id="${id}">
          <span class="tree-toggle">${hasChildren ? (isExpanded ? '‚ñº' : '‚ñ∂') : ''}</span>
          <span class="tree-tag">&lt;${node.tag || 'div'}&gt;</span>
          <span class="tree-type">${node.type || ''}</span>
          ${displayName ? `<span class="tree-name">"${escapeHtml(displayName)}"</span>` : ''}
          ${classNames.length > 0 ? `<span class="tree-classes">.${classNames.slice(0, 3).join(' .')}${classNames.length > 3 ? ' +' + (classNames.length - 3) : ''}</span>` : ''}
        </div>
    `;
    
    if (isExpanded && hasChildren) {
      html += '<div class="tree-children">';
      node.children.forEach(childId => {
        const child = nodeMap[childId];
        if (child) html += renderNode(child, depth + 1);
      });
      html += '</div>';
    }
    
    html += '</div>';
    return html;
  }
  
  if (els.explorerTreeContent) {
    els.explorerTreeContent.innerHTML = rootNodes.map(n => renderNode(n)).join('') || '<p class="empty-msg">No elements found</p>';
    
    // Add click handlers
    els.explorerTreeContent.querySelectorAll('.tree-node-header').forEach(el => {
      el.addEventListener('click', () => {
        const id = el.dataset.nodeId;
        if (explorerExpandedNodes.has(id)) {
          explorerExpandedNodes.delete(id);
        } else {
          explorerExpandedNodes.add(id);
        }
        renderExplorerTree(nodes, nodeMap, styleMap);
      });
    });
  }
}

function renderExplorerStyles(styles) {
  const filteredStyles = explorerSearchTerm
    ? styles.filter(s => s.name?.toLowerCase().includes(explorerSearchTerm))
    : styles;
  
  if (els.explorerStylesContent) {
    els.explorerStylesContent.innerHTML = filteredStyles.map(style => {
      const id = 'style-' + style._id;
      const isExpanded = explorerExpandedNodes.has(id);
      const variantCount = style.variants ? Object.keys(style.variants).length : 0;
      const pageCount = style.usedOnPages?.length || 0;
      
      let html = `
        <div class="style-item">
          <div class="style-header" data-style-id="${id}">
            <span class="tree-toggle">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>
            <span class="style-name">.${escapeHtml(style.name || 'unnamed')}</span>
            ${style.comb === '&' ? '<span class="style-badge">combo</span>' : ''}
            ${variantCount > 0 ? `<span class="style-variants">${variantCount} variants</span>` : ''}
            ${pageCount > 1 ? `<span class="style-pages">${pageCount} pages</span>` : ''}
          </div>
      `;
      
      if (isExpanded) {
        const cssFormatted = style.styleLess
          ? style.styleLess.split(';').filter(Boolean).map(s => s.trim()).join(';\n')
          : '/* No styles */';
        
        html += `
          <div class="style-details">
            <div class="style-id">ID: ${style._id}</div>
            <div class="style-css">${escapeHtml(cssFormatted)}</div>
        `;
        
        if (variantCount > 0) {
          html += '<div class="variant-section"><div class="variant-label">Variants:</div>';
          Object.entries(style.variants).forEach(([name, data]) => {
            const variantCss = data.styleLess
              ? data.styleLess.split(';').filter(Boolean).map(s => s.trim()).join(';\n')
              : '/* No styles */';
            html += `
              <div style="margin: 8px 0;">
                <span class="variant-name">${escapeHtml(name)}:</span>
                <div class="style-css">${escapeHtml(variantCss)}</div>
              </div>
            `;
          });
          html += '</div>';
        }
        
        if (style.usedOnPages && style.usedOnPages.length > 0) {
          html += `<div class="variant-section"><div class="variant-label">Used on: ${style.usedOnPages.join(', ')}</div></div>`;
        }
        
        html += '</div>';
      }
      
      html += '</div>';
      return html;
    }).join('') || '<p class="empty-msg">No styles found</p>';
    
    // Add click handlers
    els.explorerStylesContent.querySelectorAll('.style-header').forEach(el => {
      el.addEventListener('click', () => {
        const id = el.dataset.styleId;
        if (explorerExpandedNodes.has(id)) {
          explorerExpandedNodes.delete(id);
        } else {
          explorerExpandedNodes.add(id);
        }
        renderExplorerStyles(styles);
      });
    });
  }
}

function renderExplorerRaw() {
  if (!els.explorerRawContent) return;
  
  // Combine all raw data from collected pages
  const combinedData = {
    pages: collectedPages.map(p => ({
      name: p.name,
      data: p.rawData
    }))
  };
  
  els.explorerRawContent.innerHTML = `<pre class="raw-json">${escapeHtml(JSON.stringify(combinedData, null, 2))}</pre>`;
}

// ========== EXPORT FUNCTIONS ==========

async function copyJson() {
  try {
    await navigator.clipboard.writeText(els.exportOutput.value);
    showToast('Copied to clipboard!');
  } catch (e) {
    showToast('Failed to copy', true);
  }
}

function downloadJson() {
  const blob = new Blob([els.exportOutput.value], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `webflow-health-report-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('Report downloaded!');
}
</script></body></html>
